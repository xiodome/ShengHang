## 实现环境

### 前端实现环境

技术栈：

- HTML5
- CSS3 (响应式设计)
- JavaScript (ES6+)
- Fetch API

启动方式：

```python
python -m http.server 3000
```

访问前端页面：

```http
http://127.0.0.1:3000
```

### 后端实现环境

- Python 3.9
- 数据库：TaurusDB
- 后端框架：django 4.2.23

启动方式：

```python
python manage.py runserver
```

## 一、 数据库基本表的定义

数据库内共包含8个实体，13个基本表（8个实体表、4个关系表和系统日志表），具体定义如下：

### 1.1 用户表（User)

| 字段名称      | 类型         | 备注                                                       |
| ------------- | ------------ | ---------------------------------------------------------- |
| user_id       | INT          | 主键，创建时唯一指定                                       |
| user_name     | VARCHAR(60)  | 用户昵称                                                   |
| password      | VARCHAR(64)  | 用户登录密码                                               |
| gender        | VARCHAR(2)   | 用户性别。仅有三种值：男、女、其他                         |
| birthday      | DATE         | 用户生日                                                   |
| region        | VARCHAR(50)  | 用户地区                                                   |
| email         | VARCHAR(50)  | 用户邮箱                                                   |
| register_time | DATETIME     | 用户注册时间                                               |
| profile       | VARCHAR(768) | 用户简介                                                   |
| status        | VARCHAR(3)   | 用户当前状态。仅有两种值：正常、封禁中                     |
| visibility    | VARCHAR(8)   | 账户信息可见性。仅有三种值：私密、仅关注者可见、所有人可见 |

### 1.2 歌手表（Singer)

| 字段名称     | 类型          | 备注                               |
| ------------ | ------------- | ---------------------------------- |
| singer_id    | INT           | 主键，创建时唯一指定               |
| singer_name  | VARCHAR(60)   | 歌手名字                           |
| type         | VARCHAR(2)    | 歌手类型。仅有三种值：男、女、组合 |
| country      | VARCHAR(20)   | 歌手国家                           |
| birthday     | DATE          | 歌手生日                           |
| introduction | VARCHAR(3072) | 歌手介绍                           |

### 1.3 专辑表（Album）

| 字段名称     | 类型          | 备注                           |
| ------------ | ------------- | ------------------------------ |
| album_id     | INT           | 主键，创建时唯一指定           |
| album_title  | VARCHAR(192)  | 专辑名称                       |
| singer_id    | INT           | 外键，关联到Singer表，所属歌手 |
| release_date | DATE          | 发布时间                       |
| cover_url    | VARCHAR(255)  | 专辑封面路径                   |
| description  | VARCHAR(3072) | 专辑简介                       |

### 1.4 歌曲表（Song）

| 字段名称   | 类型         | 备注                          |
| ---------- | ------------ | ----------------------------- |
| song_id    | INT          | 主键，创建时唯一指定          |
| song_title | VARCHAR(192) | 歌曲名称                      |
| album_id   | INT          | 外键，关联到Album表，所属专辑 |
| duration   | INT          | 歌曲时长                      |
| file_url   | VARCHAR(255) | 文件url地址                   |
| play_count | INT          | 歌曲总播放次数                |

### 1.5 歌单表（Songlist)

| 字段名称       | 类型          | 备注                       |
| -------------- | ------------- | -------------------------- |
| songlist_id    | INT           | 主键，创建时唯一指定       |
| songlist_title | VARCHAR(192)  | 歌单名称                   |
| user_id        | INT           | 外键，关联User表，创建用户 |
| description    | VARCHAR(3072) | 歌单简介                   |
| create_time    | DATETIME      | 创建时间                   |
| cover_url      | VARCHAR(255)  | 封面路径                   |
| like_count     | INT           | 点赞数                     |
| is_public      | BOOLEAN       | 歌单公开性                 |

 ### 1.6 评论表（Comment)

| 字段名称     | 类型         | 备注                                         |
| ------------ | ------------ | -------------------------------------------- |
| comment_id   | INT          | 主键，创建时唯一指定                         |
| user_id      | INT          | 外键，关联User表，评论用户                   |
| target_type  | VARCHAR(10)  | 评论目标类型                                 |
| content      | VARCHAR(300) | 评论内容                                     |
| like_count   | INT          | 评论点赞数                                   |
| comment_time | DATETIME     | 评论时间                                     |
| parent_id    | INT          | 若为回复，字段记录为改评论回复的评论的ID     |
| status       | VARCHAR(3)   | 评论状态。仅有三种状态：审核中，举报中，正常 |
| target_id    | INT          | 评论目标ID                                   |

### 1.7 收藏表（Favorite)

| 字段名称      | 类型        | 备注                       |
| ------------- | ----------- | -------------------------- |
| favorite_id   | INT         | 主键，创建时唯一指定       |
| user_id       | INT         | 外键，关联User表，收藏者ID |
| target_type   | VARCHAR(10) | 收藏对象类型               |
| target_id     | INT         | 收藏对象ID                 |
| favorite_time | DATETIME    | 收藏时间                   |

### 1.8 播放记录表（PlayHistory）

| 字段名称      | 类型     | 备注                         |
| ------------- | -------- | ---------------------------- |
| play_id       | INT      | 主键，创建时唯一指定         |
| user_id       | INT      | 外键，关联User表，播放用户ID |
| song_id       | INT      | 外键，关联Song表，播放歌曲ID |
| play_time     | DATETIME | 播放时间                     |
| play_duration | INT      | 实际播放时长（秒）           |

### 1.9 用户关注关系表（UserFollow)

| 字段名称    | 类型     | 备注                             |
| ----------- | -------- | -------------------------------- |
| user_id     | INT      | 外键，关联User表，关注者用户ID   |
| singer_id   | INT      | 外键，关联Singer表，被关注用户ID |
| follow_time | DATETIME | 关注时间                         |

### 1.10 歌手粉丝表（SingerFollow）

| 字段名称    | 类型     | 备注                             |
| ----------- | -------- | -------------------------------- |
| user_id     | INT      | 外键，关联User表，关注用户ID     |
| singer_id   | INT      | 外键，关联Singer表，被关注歌手ID |
| follow_time | DATETIME | 关注时间                         |

### 1.11 歌单-歌曲关系表（SonglistSong）

| 字段名称    | 类型     | 备注                         |
| ----------- | -------- | ---------------------------- |
| songlist_id | INT      | 外键，关联Songlist表，歌单ID |
| song_id     | INT      | 外键，关联Song表，歌曲ID     |
| add_time    | DATETIME | 添加时间                     |

### 1.12 歌曲-歌手关系表（SongSinger）

| 字段名称  | 类型 | 备注                       |
| --------- | ---- | -------------------------- |
| song_id   | INT  | 外键，关联Song表，歌曲ID   |
| singer_id | INT  | 外键，关联Singer表，歌手ID |

### 1.13 系统日志表（SystemLog）

| 字段名称     | 类型         | 备注                                  |
| ------------ | ------------ | ------------------------------------- |
| log_id       | INT          | 主键，创建时唯一指定                  |
| action       | VARCHAR(255) | 操作内容                              |
| target_table | VARCHAR(64)  | 被操作数据表名                        |
| target_id    | INT          | 被操作记录ID                          |
| action_time  | DATETIME     | 操作时间                              |
| result       | VARCHAR(10)  | 操作结果，仅有两种状态：success、fail |

## 二、 触发器与存储过程的设计与实现说明

 ### 2.1 触发器的设计与实现



### 2.2 存储过程的设计与实现

#### 2.2.1 用户管理模块

##### 根路由

/user

##### 用户注册

- 路径 /register/
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 JSON/表单数据

| 字段名   | 类型   | 可选 | 解释     | 备注                   |
| -------- | ------ | ---- | -------- | ---------------------- |
| username | string | -    | 用户名   | 长度至少为 4           |
| password | string | -    | 密码     | 长度至少为 6           |
| email    | string | ✔    | 邮箱     | 必须全局唯一           |
| gender   | string | ✔    | 性别     | '男', '女', '其他'(默) |
| birthday | date   | ✔    | 生日日期 | 格式 YYYY-MM-DD        |
| region   | string | ✔    | 地区     | -                      |
| profile  | string | ✔    | 个人简介 | -                      |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def register(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)
    
    try:
        data = json.loads(request.body)
    except:
        data = request.POST


    # ----------------------------
    # 1. 数据获取
    # ----------------------------
    username = data.get("username")
    password = data.get("password")

    # -------- 可选字段，但要处理默认值 -------- 
    # 需要处理的所有可选字段
    optional_fields = ["gender", "birthday", "region", "email", "profile"]

    # 默认值
    defaults = {
        "gender": "其他",
        "birthday": None,
        "region": None,
        "email": None,
        "profile": None,
    }

    # 解析字段
    cleaned = {}
    for field in optional_fields:
        value = data.get(field, defaults[field])
        if value == "":
            value = defaults[field]
        cleaned[field] = value

    # 获得最终值
    gender = cleaned["gender"]
    birthday = cleaned["birthday"]
    region = cleaned["region"]
    email = cleaned["email"]
    profile = cleaned["profile"]


    # ----------------------------
    # 2. 基础校验
    # ----------------------------
    if not username or not password:
        return json_cn({"error": "请输入用户名和密码"}, 400)

    if len(username) < 4:
        return json_cn({"error": "用户名长度至少为4"}, 400)

    if len(password) < 6:
        return json_cn({"error": "密码长度至少为6"}, 400)

    # ----------------------------
    # 3. 禁止传入账号状态 status 和 register_time
    # ----------------------------
    if "status" in data:
        return json_cn({"error": "status field is not allowed"}, 400)

    if "register_time" in data:
        return json_cn({"error": "register_time cannot be set manually"}, 400)
    # ----------------------------
    # 4. 检查用户名是否已存在
    # ----------------------------
    sql_check_name = "SELECT user_id FROM User WHERE user_name = %s"
    with connection.cursor() as cursor:
        cursor.execute(sql_check_name, [username])
        if cursor.fetchone():
            return json_cn({"error": "用户名已存在"}, 400)

    # ----------------------------
    # 5. 检查邮箱是否唯一
    # ----------------------------
    if email:
        sql_check_email = "SELECT user_id FROM User WHERE email = %s"
        with connection.cursor() as cursor:
            cursor.execute(sql_check_email, [email])
            if cursor.fetchone():
                return json_cn({"error": "邮箱已存在"}, 400)

    # ----------------------------
    # 6. 插入用户（使用原生 SQL）
    # ----------------------------
    hashed_pw = hash_password(password)

    sql_insert = """
        INSERT INTO User (user_name, password, gender, birthday, region, email, profile)
        VALUES (%s, %s, %s, %s, %s, %s, %s)
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_insert, [
            username, hashed_pw, gender, birthday, region, email, profile
        ])
        
    return json_cn({"message": "注册成功"})
```

##### 用户登录

- 路径 /login/
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 JSON/表单数据

| 字段名   | 类型   | 可选 | 解释   | 备注 |
| -------- | ------ | ---- | ------ | ---- |
| username | string | -    | 用户名 | -    |
| password | string | -    | 密码   | -    |

- 成功响应

| 字段名   | 类型   | 解释     | 备注               |
| -------- | ------ | -------- | ------------------ |
| message  | string | 提示信息 | -                  |
| user_id  | int    | 用户 ID  | -                  |
| username | string | 用户名   | -                  |
| is_admin | bool   | 是否管理 | 用于前端判断权限页 |

```python
@csrf_exempt
def login(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # ----------------------------
    # 1. 数据获取
    # ----------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST
    

    username = data.get("username")
    password = hash_password(data.get("password"))


    # ----------------------------
    # 2. 数据校验
    # ----------------------------
    sql = """SELECT user_id, status FROM User WHERE user_name=%s AND password=%s"""
    
    with connection.cursor() as cursor:
        cursor.execute(sql, [username, password])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "用户名或密码错误"}, 400)

    uid, status = row

    if status == "封禁中":
        return json_cn({"error": "用户封禁中"}, 403)

    request.session["user_id"] = uid

    # ----------------------------
    # 3. 特判管理员 user_id
    # ----------------------------
    if uid == ADMIN_USER_ID:
        return json_cn({
            "message": "管理员登录成功",
            "user_id": uid,
            "username": username,
            "is_admin": True
        })
    
    return json_cn({
        "message": "登录成功",
        "user_id": uid,
        "username": username,
        "is_admin": False
    })
```

##### 用户退出

- 路径 /logout
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 无

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
def logout(request):
    # ----------------------------
    # 1. 登录检查
    # ----------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "您尚未登录"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # ----------------------------
    # 2. 执行退出
    # ----------------------------  
    request.session.flush()
    return json_cn({"message": "退出成功"})
```

#####  用户注销

- 路径 /delete_account
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

|  字段名  |  类型  | 可选 |   解释   | 备注 |
| :------: | :----: | :--: | :------: | :--: |
| password | string |  -   | 账户密码 |  -   |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def delete_account(request):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    user_id = request.session.get("user_id")
    if not user_id:
        return json_cn({"error": "请先登录"}, 401)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # 兼容 JSON 和 form
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    password_raw = data.get("password")
    if not password_raw:
        return json_cn({"error": "请输入密码"}, 400)
    password = hash_password(password_raw)

    # --------------------------
    # 2. 查询用户真实密码（SQL）
    # --------------------------
    sql_get_user = "SELECT password FROM User WHERE user_id = %s"

    with connection.cursor() as cursor:
        cursor.execute(sql_get_user, [user_id])
        row = cursor.fetchone()

        if not row:
            return json_cn({"error": "用户不存在"}, 404)

        real_hashed_pw = row[0]

    # --------------------------
    # 3. 校验密码
    # --------------------------
    if password != real_hashed_pw:
        return json_cn({"error": "密码错误，无法注销账号"}, 403)


    # --------------------------
    # 4. 删除用户（SQL）
    # --------------------------
    sql_delete = "DELETE FROM User WHERE user_id = %s"

    with connection.cursor() as cursor:
        cursor.execute(sql_delete, [user_id])

    # --------------------------
    # 5. 注销 session
    # --------------------------
    request.session.flush()

    return json_cn({"message": "账号已成功注销"})
```

##### 修改密码

- 路径 /change_password
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

|    字段名    |  类型  | 可选 |    解释    |                       备注                        |
| :----------: | :----: | :--: | :--------: | :-----------------------------------------------: |
| old_password | string |  -   | 旧账户密码 |          旧账户密码要与数据库内密码相同           |
| new_password | string |  -   | 新账户密码 | 新密码不能为空，且长度至少为6位，新旧密码不能相同 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def change_password(request):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    uid = request.session.get("user_id")
    if not uid:
        return json_cn({"error": "请先登录"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    old_pw_raw = data.get("old_password")
    new_pw_raw = data.get("new_password")

    # --------------------------
    # 2. 密码校验
    # --------------------------
    if not old_pw_raw or not new_pw_raw:
        return json_cn({"error": "旧密码或新密码不能为空"}, 400)

    if len(new_pw_raw) < 6:
        return json_cn({"error": "新密码长度至少为 6 位"}, 400)

    if new_pw_raw == old_pw_raw:
        return json_cn({"error": "新密码不能与旧密码相同"}, 400)

    
    old_pw = hash_password(old_pw_raw)
    new_pw = hash_password(new_pw_raw)

    # --------------------------
    # 3. 旧密码校验
    # --------------------------
    sql_check = "SELECT user_id FROM User WHERE user_id=%s AND password=%s"
    sql_update = "UPDATE User SET password=%s WHERE user_id=%s"

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [uid, old_pw])
        if not cursor.fetchone():
            return json_cn({"error": "旧密码错误"}, 403)

        cursor.execute(sql_update, [new_pw, uid])

    return json_cn({"message": "密码修改成功"})
```

##### 个人界面显示

- 路径 /profile/{owner_id}/
- 方法 GET (通过 URL 访问)
- 路径参数

| 字段名   | 类型 | 解释     | 备注 |
| -------- | ---- | -------- | ---- |
| owner_id | int  | 目标用户 | -    |

- 查询参数 无
- 请求体 无
- 成功响应

| 字段名   | 类型   | 解释         | 备注             |
| -------- | ------ | ------------ | ---------------- |
| user_id  | int    | 用户 ID      | -                |
| username | string | 用户名       | -                |
| gender   | string | 性别         | -                |
| birthday | string | 生日         | -                |
| region   | string | 地区         | -                |
| email    | string | 邮箱         | -                |
| profile  | string | 简介         | -                |
| is_owner | bool   | 是否是该用户 | 用于前端显示编辑 |

```python
@csrf_exempt
def profile(request, owner_id):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    user_id = request.session.get("user_id")
    if not user_id:
        return json_cn({"error": "请先登录"}, 403)
    
    # 判断是否为本人
    is_owner = (owner_id == user_id)

    # --------------------------
    # 2. 查询个人信息
    # --------------------------
    sql = """
        SELECT user_name, gender, birthday, region, email, profile 
        FROM User WHERE user_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [owner_id])
        row = cursor.fetchone()

        if not row:
            return json_cn({"error": "用户不存在"}, 404)

        username, gender, birthday, region, email, profile_text = row

    # --------------------------
    # 3. 处理空值
    # --------------------------
    gender = gender if gender else None
    region = region if region else None
    email = email if email else None
    profile_text = profile_text if profile_text else None
    birthday = str(birthday) if birthday else None

    # --------------------------
    # 4. 返回用户信息
    # --------------------------
    return json_cn({
        "user_id": owner_id,
        "username": username,
        "gender": gender,
        "birthday": birthday,
        "region": region,
        "email": email,
        "profile": profile_text,
        "is_owner": is_owner
    })
```

##### 个人信息修改

- 路径 /update_profile
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名   | 类型   | 可选 | 解释     | 备注                                             |
| -------- | ------ | ---- | -------- | ------------------------------------------------ |
| email    | string | ✔    | 邮箱     | 必须全局唯一，五个字段必须有一个不为空           |
| gender   | string | ✔    | 性别     | '男', '女', '其他'(默)，五个字段必须有一个不为空 |
| birthday | date   | ✔    | 生日日期 | 格式 YYYY-MM-DD，五个字段必须有一个不为空        |
| region   | string | ✔    | 地区     | 五个字段必须有一个不为空                         |
| profile  | string | ✔    | 个人简介 | 五个字段必须有一个不为空                         |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def update_profile(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再修改个人信息"}, 403)
    uid = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST
        

    # --------------------------
    # 2. 获取新个人信息并校验
    # --------------------------   
    fields = []
    values = []
    for key in ["gender", "birthday", "email", "region", "profile"]:
        if key in data and data[key].strip() != "":  # 空字符串不更新
            if key == "gender" and data[key] not in ["男", "女", "其他"]:
                return json_cn({"error": "非法性别，只能为：男/女/其他"}, 400)
            if key == "birthday":
                try:
                    datetime.datetime.strptime(data[key], "%Y-%m-%d")
                except ValueError:
                    return json_cn({"error": "生日格式应为 YYYY-MM-DD"}, 400)
            if key == "email":
                sql_check_email = "SELECT user_id FROM User WHERE email=%s AND user_id<>%s"
                with connection.cursor() as cursor:
                    cursor.execute(sql_check_email, [data[key], uid])
                    if cursor.fetchone():
                        return json_cn({"error": "邮箱已存在"}, 400)
            fields.append(f"{key}=%s")
            values.append(data[key])

    if not fields:
        return json_cn({"error": "请输入修改信息"}, 400)

    # --------------------------
    # 3. 更新个人信息
    # --------------------------
    sql_update = f"UPDATE User SET {', '.join(fields)} WHERE user_id=%s"
    values.append(uid)

    with connection.cursor() as cursor:
        cursor.execute(sql_update, values)

    return json_cn({"message": "个人信息修改成功"})
```

##### 关注用户

- 路径 /follow_user
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名  |  类型  | 可选 |     解释     |                           备注                           |
| :-----: | :----: | :--: | :----------: | :------------------------------------------------------: |
| user_id | string |  -   | 关注用户的ID | 关注用户不能已经关注过，并且ID不能与发起关注用户的ID相同 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def follow_user(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    follower = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 获取目标用户名并查询
    # --------------------------
    target_user_id = data.get("user_id")

    if not target_user_id:
        return json_cn({"error": "请输入 user_id 参数"}, 400)


    sql_get_target = "SELECT 1 FROM User WHERE user_id=%s"

    with connection.cursor() as cursor:
        cursor.execute(sql_get_target, [target_user_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "用户不存在"}, 404)

    # --------------------------
    # 3. 不允许操作自己
    # --------------------------
    if int(target_user_id) == follower:
        return json_cn({"error": "不能对自己进行操作"}, 400)

    # --------------------------
    # 4. 关注逻辑
    # --------------------------
    # 检查是否已关注
    sql_check = """
        SELECT * FROM UserFollow
        WHERE follower_id=%s AND followed_id=%s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [follower, target_user_id])
        if cursor.fetchone():
            return json_cn({"error": "已关注该用户"}, 400)

    # 插入关注关系
    sql_follow = """INSERT INTO UserFollow(follower_id, followed_id) 
                    VALUES (%s, %s)"""

    with connection.cursor() as cursor:
        cursor.execute(sql_follow, [follower, target_user_id])

    return json_cn({"message": "关注成功"})
```

##### 取关用户

- 路径 /unfollow_user
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名  |  类型  | 可选 |     解释     |                           备注                           |
| :-----: | :----: | :--: | :----------: | :------------------------------------------------------: |
| user_id | string |  -   | 取关用户的ID | 取关的用户不能未关注过，并且ID不能与发起取关用户的ID相同 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def unfollow_user(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    follower = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 获取目标用户名并查询
    # --------------------------
    target_user_id = data.get("user_id")

    if not target_user_id:
        return json_cn({"error": "请输入 user_id 参数"}, 400)


    sql_get_target = "SELECT 1 FROM User WHERE user_id=%s"

    with connection.cursor() as cursor:
        cursor.execute(sql_get_target, [target_user_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "用户不存在"}, 404)

    # --------------------------
    # 3. 不允许操作自己
    # --------------------------
    if int(target_user_id) == follower:
        return json_cn({"error": "不能对自己进行操作"}, 400)

    # --------------------------
    # 4. 取关逻辑
    # --------------------------
    # 检查是否未关注
    sql_check = """
        SELECT * FROM UserFollow
        WHERE follower_id=%s AND followed_id=%s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [follower, target_user_id])
        if not cursor.fetchone():
            return json_cn({"error": "未关注该用户，不能取关"}, 400)

    # 删除关注关系
    sql_follow = """DELETE FROM UserFollow 
                WHERE follower_id = %s AND followed_id = %s
            """

    with connection.cursor() as cursor:
        cursor.execute(sql_follow, [follower, target_user_id])

    return json_cn({"message": "取关成功"})
```

##### 关注歌手

- 路径 /follow_singer
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

|  字段名   |  类型  | 可选 |     解释     |           备注           |
| :-------: | :----: | :--: | :----------: | :----------------------: |
| singer_id | string |  -   | 关注歌手的ID | 关注过的歌手不能再次关注 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def follow_singer(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    follower = request.session["user_id"]
    
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)
        
    try:
        data = json.loads(request.body)
    except:
        data = request.POST
    
    singer_id = data.get("singer_id")

    if not singer_id:
        return json_cn({"error": "请输入 singer_id"}, 400)


    # --------------------------
    # 2. 查找目标歌手
    # --------------------------
    sql_get_target = "SELECT 1 FROM Singer WHERE singer_id = %s"

    with connection.cursor() as cursor:
        cursor.execute(sql_get_target, [singer_id])
        exist = cursor.fetchone()

    if not exist:
        return json_cn({"error": "目标歌手不存在"}, 404)

    # --------------------------
    # 3. 关注逻辑
    # --------------------------
    # 检查是否已关注
    sql_check = """
        SELECT * FROM SingerFollow
        WHERE user_id=%s AND singer_id=%s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [follower, singer_id])
        if cursor.fetchone():
            return json_cn({"error": "已关注该歌手"}, 400)

    # 插入关注关系
    sql_follow = """INSERT INTO SingerFollow(user_id, singer_id) 
                    VALUES (%s, %s)"""

    with connection.cursor() as cursor:
        cursor.execute(sql_follow, [follower, singer_id])

    return json_cn({"message": "关注成功"})
```

##### 取关歌手

- 路径 /unfollow_singer
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

|  字段名   |  类型  | 可选 |     解释     |          备注          |
| :-------: | :----: | :--: | :----------: | :--------------------: |
| singer_id | string |  -   | 取关歌手的ID | 取关的歌手不能未关注过 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def unfollow_singer(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    follower = request.session["user_id"]
    
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)
        
    try:
        data = json.loads(request.body)
    except:
        data = request.POST
    
    singer_id = data.get("singer_id")

    if not singer_id:
        return json_cn({"error": "请输入 singer_id"}, 400)


    # --------------------------
    # 2. 查找目标歌手
    # --------------------------
    sql_get_target = "SELECT 1 FROM Singer WHERE singer_id = %s"

    with connection.cursor() as cursor:
        cursor.execute(sql_get_target, [singer_id])
        exist = cursor.fetchone()

    if not exist:
        return json_cn({"error": "目标歌手不存在"}, 404)

    # --------------------------
    # 3. 取关逻辑
    # --------------------------
    # 检查是否已关注
    sql_check = """
        SELECT * FROM SingerFollow
        WHERE user_id=%s AND singer_id=%s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [follower, singer_id])
        if not cursor.fetchone():
            return json_cn({"error": "未关注该歌手"}, 400)

    # 删除关注关系
    sql_follow = """DELETE FROM SingerFollow
                WHERE user_id = %s AND singer_id = %s        
            """

    with connection.cursor() as cursor:
        cursor.execute(sql_follow, [follower, singer_id])

    return json_cn({"message": "取关成功"})
```

##### 查看关注用户列表 

- 路径 /{uid}/get_followers/
- 方法 POST
- 路径参数 uid
- 查询参数 无
- 请求体 表单数据

| 字段名  |  类型  | 可选 |    解释    |         备注         |
| :-----: | :----: | :--: | :--------: | :------------------: |
| user_id | string |  -   | 查看用户ID | user_id必须与uid相同 |

- 成功响应

| 字段名              | 类型   | 解释         | 备注 |
| :------------------ | :----- | :----------- | :--- |
| total_count         | int    | 关注用户人数 | -    |
| followings          | list   | 关注列表     | -    |
| followings:user_id  | int    | 用户 ID      | -    |
| followings:username | string | 用户名       | -    |

```python
@csrf_exempt
def get_followings(request, uid):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    login_user_id = request.session["user_id"]
    

    if login_user_id != uid:
        return json_cn({"error": "无权限查看他人关注用户列表"}, 403)

    
    # --------------------------
    # 2. 查询关注列表和总数
    # --------------------------
    sql = """
        SELECT u.user_name, u.user_id
        FROM UserFollow uf
        JOIN User u ON uf.followed_id = u.user_id
        WHERE uf.follower_id = %s
    """
    sql_count = """
        SELECT COUNT(*)
        FROM UserFollow
        WHERE follower_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [uid])
        rows = cursor.fetchall()

    with connection.cursor() as cursor:
        cursor.execute(sql_count, [uid])
        total_count = cursor.fetchone()[0]
    if not total_count:
        total_count = 0

    # --------------------------
    # 3. 返回关注列表和总数
    # --------------------------
    followings = [{"user_name": row[0], "user_id": row[1]} for row in rows]

    return json_cn({
        "total_count": total_count,
        "followings": followings
    })
```

##### 查看粉丝列表

- 路径 /{uid}/get_followers
- 方法 POST
- 路径参数 uid
- 查询参数 无
- 请求体 表单数据

| 字段名  |  类型  | 可选 |    解释    |         备注         |
| :-----: | :----: | :--: | :--------: | :------------------: |
| user_id | string |  -   | 查看用户ID | user_id必须与uid相同 |

- 成功响应

| 字段名             | 类型   | 解释     | 备注 |
| :----------------- | :----- | :------- | :--- |
| total_count        | int    | 粉丝人数 | -    |
| followers          | list   | 粉丝列表 | -    |
| followers:user_id  | int    | 用户 ID  | -    |
| followers:username | string | 用户名   | -    |

```python
@csrf_exempt
def get_followers(request, uid):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)
    
    login_user_id = request.session.get("user_id")
    

    if login_user_id != uid:
        return json_cn({"error": "无权限查看他人粉丝列表"}, 403)

    # --------------------------
    # 2. 查询粉丝列表和总数
    # --------------------------
    sql = """
        SELECT u.user_name, u.user_id
        FROM UserFollow uf
        JOIN User u ON uf.follower_id = u.user_id
        WHERE uf.followed_id = %s
    """
    sql_count = """
        SELECT COUNT(*)
        FROM UserFollow
        WHERE followed_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [uid])
        rows = cursor.fetchall()

    with connection.cursor() as cursor:
        cursor.execute(sql_count, [uid])
        total_count = cursor.fetchone()[0]
    if not total_count:
        total_count = 0

    # --------------------------
    # 3. 返回粉丝列表和总数
    # --------------------------
    followers = [{"user_name": row[0], "user_id": row[1]} for row in rows]

    return json_cn({
        "total_count": total_count,
        "followers": followers
    })
```

##### 查看关注歌手列表

- 路径 /{uid}/get_followsingers
- 方法 POST
- 路径参数 uid
- 查询参数 无
- 请求体 表单数据

| 字段名  |  类型  | 可选 |    解释    |         备注         |
| :-----: | :----: | :--: | :--------: | :------------------: |
| user_id | string |  -   | 查看用户ID | user_id必须与uid相同 |

- 成功响应

| 字段名                     | 类型   | 解释         | 备注 |
| :------------------------- | :----- | :----------- | :--- |
| total_count                | int    | 关注歌手人数 | -    |
| follow_singers             | list   | 关注歌手列表 | -    |
| follow_singers:singer_name | string | 歌手名称     | -    |
| follow_singers:singer_id   | int    | 歌手ID       | -    |

```python
@csrf_exempt 
def get_followsingers(request, uid):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)
    
    login_user_id = request.session.get("user_id")
    

    if login_user_id != uid:
        return json_cn({"error": "无权限查看他人关注歌手列表"}, 403)

    # --------------------------
    # 2. 查询关注歌手列表和总数
    # --------------------------
    sql = """
        SELECT s.singer_name, s.singer_id
        FROM SingerFollow sf
        JOIN Singer s ON sf.singer_id = s.singer_id
        WHERE sf.user_id = %s
    """
    sql_count = """
        SELECT COUNT(*)
        FROM SingerFollow
        WHERE user_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [uid])
        rows = cursor.fetchall()

    with connection.cursor() as cursor:
        cursor.execute(sql_count, [uid])
        total_count = cursor.fetchone()[0]
    if not total_count:
        total_count = 0

    # --------------------------
    # 3. 返回关注歌手列表和总数
    # --------------------------
    follow_singers = [{"singer_name": row[0], "singer_id": row[1]} for row in rows]

    return json_cn({
        "total_count": total_count,
        "follow_singers": follow_singers
    })
```

##### 查看他人信息

- 路径 /get_user_info
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

|  字段名   |  类型  | 可选 |     解释     | 备注 |
| :-------: | :----: | :--: | :----------: | :--: |
| user_name | string |  -   | 查看用户昵称 |  -   |

- 成功响应

| 字段名    | 类型   | 解释         | 备注 |
| :-------- | :----- | :----------- | :--- |
| user_name | string | 查看用户昵称 | -    |
| user_id   | int    | 查看用户ID   | -    |

```python
@csrf_exempt
def get_user_info(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)
    
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # 解析 JSON
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 根据用户名查找用户信息
    # --------------------------
    user_name = data.get("user_name")

    sql = """
        SELECT user_name, user_id
        FROM User
        WHERE user_name=%s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [user_name])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "用户不存在"}, 404)

    username, target_user_id = row

    # --------------------------
    # 3. 返回用户信息
    # --------------------------
    return json_cn({
        "user_name": username,
        "user_id": target_user_id
    })
```

##### 修改个人信息可见性

- 路径 /update_visibility
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

|   字段名   |  类型  | 可选 |   解释   |                     备注                     |
| :--------: | :----: | :--: | :------: | :------------------------------------------: |
| visibility | string |  -   | 新可见性 | 仅有三种取值：私密、仅关注者可见、全部人可见 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| :------ | :----- | :------- | :--- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def update_visibility(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再修改可见性"}, 403)
    uid = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 获取新可见性并校验
    # --------------------------
    visibility = data.get("visibility")
    if visibility not in ["私密", "仅关注者可见", "全部人可见"]:
        return json_cn({"error": "可见性参数非法，只能为：私密/仅关注者可见/全部人可见"}, 400)

    # --------------------------
    # 3. 更新数据库
    # --------------------------
    sql_update = "UPDATE User SET visibility=%s WHERE user_id=%s"
    with connection.cursor() as cursor:
        cursor.execute(sql_update, [visibility, uid])

    return json_cn({"message": "个人信息可见性修改成功", "visibility": visibility})
```

#### 2.2.2 歌手与音乐管理模块

##### 搜索歌手

- 路径 /singer/search_singer
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名      | 类型   | 可选 | 解释         | 备注                                       |
| ----------- | ------ | ---- | ------------ | ------------------------------------------ |
| type        | string | ✔    | 查询歌手类型 | '男', '女', '其他'(默)<br />为空则搜索全部 |
| country     | string | ✔    | 查询歌手国籍 | 为空则搜索全部                             |
| singer_name | string | ✔    | 查询歌手名字 | 为空则搜索全部                             |

- 成功响应

| 字段名              | 类型   | 解释               | 备注 |
| :------------------ | :----- | :----------------- | :--- |
| total               | int    | 符合条件的歌手数量 | -    |
| singers             | list   | 符合条件的歌手     | -    |
| singers:singer_id   | int    | 符合条件的歌手ID   | -    |
| singers:singer_name | string | 符合条件的歌手名字 | -    |
| singers:type        | string | 符合条件的歌手类型 | -    |
| singers:country     | string | 符合条件的歌手国籍 | -    |

```python
@csrf_exempt
def search_singer(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)
    
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 获取筛选标签
    # --------------------------
    filters = []
    params = []

    singer_type = data.get("type")
    country = data.get("country")
    singer_name = data.get("singer_name")

    if singer_type and singer_type != "":
        filters.append("type = %s")
        params.append(singer_type)
    if country and country != "":
        filters.append("country = %s")
        params.append(country)
    if singer_name and singer_name != "":
        filters.append("singer_name LIKE %s")
        params.append("%" + singer_name + "%")

    # --------------------------
    # 3. 正式查找歌手
    # --------------------------

    where_clause = "WHERE " + " AND ".join(filters) if filters else ""

    sql = f"""
        SELECT singer_id, singer_name, type, country
        FROM Singer
        {where_clause}
        ORDER BY singer_name ASC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, params)
        rows = cursor.fetchall()

    # ------------------------
    # 4. 查询数量
    # ------------------------
    sql_count = f"""
        SELECT COUNT(*)
        FROM Singer
        {where_clause}
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_count, params)
        total = cursor.fetchone()[0]


    # --------------------------
    # 5. 返回搜索结果
    # --------------------------
    singers = []
    for (singer_id, singer_name, singer_type, country) in rows:
        singers.append({
            "singer_id": singer_id,
            "singer_name": singer_name,
            "type": singer_type,
            "country": country
        })

    return json_cn({
        "total": total,
        "singers": singers
    })
```

##### 查看歌手详情

- 路径 /singer/profile/{singer_id}
- 方法 POST
- 路径参数 singer_id
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                   | 类型   | 解释               | 备注                   |
| :----------------------- | :----- | :----------------- | :--------------------- |
| singer_id                | int    | 查看的歌手ID       | -                      |
| singer_name              | string | 查看的歌手名字     | -                      |
| type                     | string | 查看的歌手类型     | '男', '女', '其他'(默) |
| country                  | string | 查看的歌手国籍     | -                      |
| birthday                 | string | 查看的歌手生日日期 | 格式 YYYY-MM-DD        |
| introduction             | string | 查看的歌手简介     | -                      |
| song_count               | int    | 查看的歌手歌曲数量 | -                      |
| songs                    | list   | 查看歌手发布的歌曲 | -                      |
| songs:song_id            | int    | 歌曲ID             | -                      |
| songs:song_title         | string | 歌曲名称           | -                      |
| songs:duration           | int    | 歌曲时长           | -                      |
| songs:duration_formatted | string | 格式化后歌曲时长   | 格式 mm:ss             |
| songs:album_title        | string | 歌曲所属专辑       | -                      |
| album_count              | int    | 查看的歌手专辑数量 | -                      |
| albums                   | list   | 查看的歌手专辑     | -                      |
| albums:album_id          | int    | 专辑ID             | -                      |
| albums:album_title       | string | 专辑名称           | -                      |
| albums:release_date      | string | 专辑发行日期       | -                      |

```python
@csrf_exempt
def singer_profile(request, singer_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行查看操作"}, 403)

    # --------------------------
    # 2. 查询歌手信息
    # --------------------------
    sql_list = """
        SELECT singer_name, type, country, birthday, introduction
        FROM Singer
        WHERE singer_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_list, [singer_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "歌手不存在"}, 404)

    singer_name, singer_type, country, birthday, introduction = row


    # --------------------------
    # 3. 查询歌手的歌曲列表
    # --------------------------
    sql_songs = """
        SELECT 
            s.song_id,
            s.song_title,
            s.duration,
            a.album_title
        FROM Song s
        JOIN Album a ON s.album_id = a.album_id
        JOIN Song_Singer ss ON s.song_id = ss.song_id
        WHERE ss.singer_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_songs, [singer_id])
        song_rows = cursor.fetchall()

    # --------------------------
    # 4. 生成歌手歌曲列表
    # --------------------------
    songs = []
    for (song_id, song_title, duration, album_title) in song_rows:
        songs.append({
            "song_id": song_id,
            "song_title": song_title,
            "duration": duration,
            "duration_formatted": format_time(duration),
            "album_title": album_title
        })


    # --------------------------
    # 5. 查询歌手的专辑列表
    # --------------------------
    sql_albums = """
        SELECT 
            a.album_id,
            a.album_title,
            a.release_date
        FROM Album a
        JOIN Singer s ON s.singer_id = a.singer_id
        WHERE s.singer_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_albums, [singer_id])
        album_rows = cursor.fetchall()

    # --------------------------
    # 6. 生成歌手专辑列表
    # --------------------------
    albums = []
    for (album_id, album_title, release_date) in album_rows:
        albums.append({
            "album_id": album_id,
            "album_title": album_title,
            "release_date": str(release_date) if release_date else None
        })

    # --------------------------
    # 7. 返回歌手详情
    # --------------------------
    return json_cn({
        "singer_id": singer_id,
        "singer_name": singer_name,
        "type": singer_type,
        "country": country,
        "birthday": str(birthday) if birthday else None,
        "introduction": introduction,
        "song_count": len(songs),
        "songs": songs,
        "album_count": len(albums),
        "albums": albums
    })
```

##### 搜索专辑

- 路径 /album/search_album
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名      | 类型   | 可选 | 解释         | 备注           |
| ----------- | ------ | ---- | ------------ | -------------- |
| album_title | string | ✔    | 查询专辑名称 | 为空则搜索全部 |
| singer_name | string | ✔    | 查询歌手名称 | 为空则搜索全部 |

- 成功响应

| 字段名              | 类型   | 解释                     | 备注 |
| :------------------ | :----- | :----------------------- | :--- |
| total               | int    | 查询到的符合条件专辑数量 | -    |
| albums              | list   | 查看的歌手专辑           | -    |
| albums:album_id     | int    | 专辑ID                   | -    |
| albums:album_title  | string | 专辑名称                 | -    |
| albums:singer_name  | string | 专辑所属歌手名称         |      |
| albums:release_date | string | 专辑发行日期             | -    |

```python
@csrf_exempt
def search_album(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)
    
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 获取搜索标签
    # --------------------------
    album_title = data.get("album_title", "").strip()
    singer_name = data.get("singer_name", "").strip()

    filters = []
    params = []

    if album_title:
        filters.append("a.album_title LIKE %s")
        params.append(f"%{album_title}%")
    if singer_name:
        filters.append("s.singer_name LIKE %s")
        params.append(f"%{singer_name}%")


    # --------------------------
    # 3. 查询专辑信息
    # --------------------------
    sql_album = """
        SELECT a.album_title, sg.singer_name, a.release_date, a.album_id
        FROM Album a
        JOIN Singer sg ON a.singer_id = sg.singer_id
    """

    if filters:
        sql_album += " WHERE " + " AND ".join(filters)

    sql_album += " GROUP BY a.album_id"

    with connection.cursor() as cursor:
        cursor.execute(sql_album, params)
        rows = cursor.fetchall()


    if not rows:
        return json_cn({"message": "未找到符合条件专辑", "albums": []})


    # --------------------------
    # 4. 返回搜索结果
    # --------------------------
    albums = []
    for (album_title, singer_name, release_date, album_id) in rows:
        albums.append({
            "album_id": album_id,
            "album_title": album_title,
            "singer_name": singer_name,
            "release_date": str(release_date) if release_date else None
        })

    return json_cn({
        "total": len(albums),
        "albums": albums
    })
```

##### 查看专辑详情

- 路径 /album/profile/{album_id}
- 方法 POST
- 路径参数 album_id
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                    | 类型    | 解释                       | 备注                |
| :------------------------ | :------ | :------------------------- | :------------------ |
| album_id                  | int     | 专辑ID                     | -                   |
| album_title               | string  | 专辑名称                   | -                   |
| singer_id                 | int     | 专辑所属歌手ID             | -                   |
| singer_name               | string  | 专辑所属歌手名称           | -                   |
| release_date              | string  | 专辑发行日期               | -                   |
| cover_url                 | string  | 专辑封面url地址            | -                   |
| description               | string  | 专辑简介                   | -                   |
| song_count                | int     | 专辑内歌曲总数             | -                   |
| total_duration            | int     | 专辑内歌曲总时长           | -                   |
| total_duration_formatted  | string  | 格式化后的专辑内歌曲总时长 | 格式 mm:ss          |
| songs                     | list    | 专辑内歌曲                 | -                   |
| songs:song_id             | int     | 歌曲ID                     | -                   |
| songs:song_title          | stiring | 歌曲名称                   | -                   |
| songs:duration            | int     | 歌曲时长                   | -                   |
| songs:duration_formatted  | string  | 格式化后的歌曲时长         | 格式 mm:ss          |
| songs:singers             | list    | 歌曲所属歌手               | -                   |
| songs:singers:singer_id   | int     | 歌手ID                     | -                   |
| songs:singers:singer_name | string  | 歌手名称                   | -                   |
| comment_count             | int     | 专辑评论总数               | -                   |
| comments                  | list    | 专辑评论                   | -                   |
| comments:comment_id       | int     | 评论ID                     | -                   |
| comments:user_id          | int     | 发布评论的用户ID           | -                   |
| comments:user_name        | string  | 发布评论的用户昵称         | -                   |
| comments:content          | string  | 评论内容                   | -                   |
| comments:like_count       | int     | 评论点赞数                 | -                   |
| comments:comment_time     | string  | 评论发布时间               | 格式 yy-mm-dd hh-mm |

```python
@csrf_exempt
def album_profile(request, album_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行查看操作"}, 403)

    # --------------------------
    # 2. 查询专辑信息
    # --------------------------
    sql_list = """
        SELECT album_title, release_date, cover_url, description, sg.singer_name, sg.singer_id
        FROM Album a
        JOIN Singer sg ON sg.singer_id = a.singer_id
        WHERE a.album_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_list, [album_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "专辑不存在"}, 404)

    album_title, release_date, cover_url, description, singer_name, singer_id = row


    # --------------------------
    # 3. 查询专辑的歌曲列表
    # --------------------------
    sql_albums = """
        SELECT 
            s.song_id,
            s.song_title,
            s.duration
        FROM Album a
        JOIN Song s ON s.album_id = a.album_id       
        WHERE a.album_id = %s
    """

    sql_total_duration = """
        SELECT 
            IFNULL(SUM(s.duration), 0) AS total_duration
        FROM Album a
        JOIN Song s ON s.album_id = a.album_id
        WHERE a.album_id = %s
    """

    sql_singers = """
        SELECT
            sg.singer_id,
            sg.singer_name
        FROM Singer sg
        JOIN Song_Singer ss ON ss.singer_id = sg.singer_id
        WHERE ss.song_id = %s
    """

    sql_comment = """
        SELECT 
            u.user_id, u.user_name, c.comment_id, c.content, c.like_count, c.comment_time
        FROM Comment c 
        JOIN User u ON u.user_id = c.user_id
        WHERE target_id = %s AND target_type = 'album'
        ORDER BY comment_time DESC
    """

    # --------------------------
    # 4. 查询并生成专辑歌曲列表
    # --------------------------
    songs = []

    with connection.cursor() as cursor:
        cursor.execute(sql_albums, [album_id])
        song_rows = cursor.fetchall()

        cursor.execute(sql_total_duration, [album_id])
        total_duration = cursor.fetchone()[0]
        
        for (song_id, song_title, duration) in song_rows:
            cursor.execute(sql_singers, [song_id])
            singer_rows = cursor.fetchall()
            song_singers = [{"singer_id": row[0], "singer_name": row[1]} for row in singer_rows]

            songs.append({
                "song_id": song_id,
                "song_title": song_title,
                "duration": duration,
                "duration_formatted": format_time(duration),
                "singers": song_singers
            })

        cursor.execute(sql_comment, [album_id])
        comment_rows = cursor.fetchall()


    # --------------------------
    # 5. 生成专辑评论列表
    # --------------------------
    comments = []
    for user_id, user_name, comment_id, content, like_count, comment_time in comment_rows:
        comments.append({
            "comment_id": comment_id,
            "user_id": user_id,
            "user_name": user_name,
            "content": content,
            "like_count": like_count,
            "comment_time": comment_time.strftime("%Y-%m-%d %H:%M") if comment_time else None
        })

    # --------------------------
    # 6. 返回专辑详情
    # --------------------------
    return json_cn({
        "album_id": album_id,
        "album_title": album_title,
        "singer_id": singer_id,
        "singer_name": singer_name,
        "release_date": str(release_date) if release_date else None,
        "cover_url": cover_url,
        "description": description,
        "song_count": len(songs),
        "total_duration": total_duration,
        "total_duration_formatted": format_time(total_duration),
        "songs": songs,
        "comment_count": len(comments),
        "comments": comments
    })
```

##### 搜索歌曲

- 路径 /song/search_song
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名      | 类型   | 可选 | 解释               | 备注           |
| ----------- | ------ | ---- | ------------------ | -------------- |
| song_title  | string | ✔    | 查询歌曲名称       | 为空则搜索全部 |
| album_title | string | ✔    | 查询所属的专辑名称 | 为空则搜索全部 |
| singer_name | string | ✔    | 查询所属的歌手名字 | 为空则搜索全部 |

- 成功响应

| 字段名                    | 类型   | 解释               | 备注       |
| :------------------------ | :----- | :----------------- | :--------- |
| total                     | int    | 符合条件的歌曲数量 | -          |
| songs                     | list   | 符合条件的歌曲     | -          |
| songs:songs_id            | int    | 符合条件的歌曲ID   | -          |
| songs:songs_title         | string | 符合条件的歌曲名字 | -          |
| songs:duration            | string | 符合条件的歌曲时长 | -          |
| songs:duration_formatted  | string | 格式化后的歌曲时长 | 格式 mm:ss |
| songs:album_title         | string | 歌曲所属专辑名称   | -          |
| songs:singers             | list   | 演唱歌曲的歌手     | -          |
| songs:singers:singer_id   | int    | 歌手ID             | -          |
| songs:singers:singer_name | string | 歌手名称           | -          |

```python
@csrf_exempt
def search_song(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    user_id = request.session.get("user_id")
    if not user_id:
        return json_cn({"error": "请先登录"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST    

        
    # --------------------------
    # 2. 获取搜索标签
    # --------------------------
    song_title = data.get("song_title", "").strip()
    album_title = data.get("album_title", "").strip()
    singer_name = data.get("singer_name", "").strip()

    filters = []
    params = []

    if song_title:
        filters.append("s.song_title LIKE %s")
        params.append(f"%{song_title}%")
    if album_title:
        filters.append("a.album_title LIKE %s")
        params.append(f"%{album_title}%")
    if singer_name:
        filters.append("si.singer_name LIKE %s")
        params.append(f"%{singer_name}%")


    # --------------------------
    # 3. 查询歌曲信息
    # --------------------------
    # Base SQL query
    sql_song = """
        SELECT DISTINCT s.song_id, s.song_title, s.duration, a.album_title
        FROM Song s
        JOIN Album a ON a.album_id = s.album_id
    """
    
    # Add JOIN for singer filter if needed
    if singer_name:
        sql_song += """
        JOIN Song_Singer ss ON s.song_id = ss.song_id
        JOIN Singer si ON ss.singer_id = si.singer_id
        """
    
    sql_singers = """
        SELECT si.singer_id, si.singer_name 
        FROM Singer si
        JOIN Song_Singer ss ON si.singer_id = ss.singer_id
        WHERE ss.song_id = %s
    """

    if filters:
        sql_song += " WHERE " + " AND ".join(filters)



    with connection.cursor() as cursor:
        cursor.execute(sql_song, params)
        rows = cursor.fetchall()

        if not rows:
            return json_cn({"message": "未找到符合歌曲", "songs": []})
            
        # --------------------------
        # 4. 生成歌曲列表
        # --------------------------
        songs = []
        for (song_id, song_title, duration, album_title) in rows:
            cursor.execute(sql_singers, [song_id])
            singer_rows = cursor.fetchall()
            song_singers = [{"singer_id": row[0], "singer_name": row[1]} for row in singer_rows]

            songs.append({
                "song_id": song_id,
                "song_title": song_title,
                "duration": duration,
                "duration_formatted": format_time(duration),
                "album_title": album_title,
                "singers": song_singers
            })

    return json_cn({
        "total": len(songs),
        "songs": songs
    })
```

##### 查看歌曲详情

- 路径 /song/profile/{song_id}
- 方法 POST
- 路径参数 song_id
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                | 类型   | 解释               | 备注                |
| :-------------------- | :----- | :----------------- | :------------------ |
| song_id               | int    | 歌曲ID             | -                   |
| song_title            | string | 歌曲名称           | -                   |
| duration              | int    | 歌曲时长           | 单位秒              |
| duration_formatted    | string | 格式化后的歌曲时长 | 格式 mm:ss          |
| album_id              | int    | 专辑ID             | -                   |
| album_title           | string | 专辑名称           | -                   |
| singers               | list   | 歌曲演唱歌手       | -                   |
| singers:singer_id     | int    | 歌手ID             | -                   |
| singers:singer_name   | string | 歌手名称           | -                   |
| comment_count         | int    | 歌曲评论总数       | -                   |
| comments              | list   | 歌曲评论           | -                   |
| comments:comment_id   | int    | 评论ID             | -                   |
| comments:user_id      | int    | 发布评论的用户ID   | -                   |
| comments:user_name    | string | 发布评论的用户昵称 | -                   |
| comments:content      | string | 评论内容           | -                   |
| comments:like_count   | int    | 评论点赞数         | -                   |
| comments:comment_time | string | 评论发布时间       | 格式 yy-mm-dd hh-mm |

```python
@csrf_exempt
def song_profile(request, song_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行查看操作"}, 403)

    # --------------------------
    # 2. 查询歌曲信息
    # --------------------------
    sql_song = """
        SELECT s.song_id, s.song_title, s.duration, a.album_id, a.album_title
        FROM Song s
        JOIN Album a ON a.album_id = s.album_id
        WHERE s.song_id = %s
    """

    sql_singer = """
        SELECT sg.singer_id, sg.singer_name
        FROM Singer sg
        JOIN Song_Singer ss ON ss.singer_id = sg.singer_id
        WHERE ss.song_id = %s
    """

    sql_comment = """
        SELECT 
            u.user_id, u.user_name, c.comment_id, c.content, c.like_count, c.comment_time
        FROM Comment c 
        JOIN User u ON u.user_id = c.user_id
        WHERE target_id = %s AND target_type = 'song'
        ORDER BY comment_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_song, [song_id])
        song_row = cursor.fetchone()
        
        if not song_row:
            return json_cn({"error": "歌曲不存在"}, 404)
        
        song_id, song_title, duration, album_id, album_title = song_row

        cursor.execute(sql_singer, [song_id])
        singer_rows = cursor.fetchall()
        singers = [{"singer_id": row[0], "singer_name": row[1]} for row in singer_rows]

        cursor.execute(sql_comment, [song_id])
        comment_rows = cursor.fetchall()


    # --------------------------
    # 3. 生成歌曲评论列表
    # --------------------------
    comments = []
    for user_id, user_name, comment_id, content, like_count, comment_time in comment_rows:
        comments.append({
            "comment_id": comment_id,
            "user_id": user_id,
            "user_name": user_name,
            "content": content,
            "like_count": like_count,
            "comment_time": comment_time.strftime("%Y-%m-%d %H:%M") if comment_time else None
        })


    # --------------------------
    # 4. 返回歌曲详情
    # --------------------------
    return json_cn({
        "song_id": song_id,
        "song_title": song_title,
        "duration": duration,
        "duration_formatted": format_time(duration),
        "album_id": album_id,
        "album_title": album_title,
        "singers": singers,
        "comment_count": len(comments),
        "comments": comments
    })
```

#### 2.2.3 收藏与歌单模块

##### 根路由

- 歌单相关：/songlist
- 收藏相关：/favorite

##### 展示歌单中心

- 路径 /list_songlists
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名    | 类型   | 可选 | 解释         | 备注                  |
| --------- | ------ | ---- | ------------ | --------------------- |
| is_public | string | ✔    | 歌单的可见性 | 可为 None / "1" / "0" |
| sort_by   | string | ✔    | 排序关键字   | 默认按创建时间排序    |

- 成功响应

| 字段名                   | 类型   | 解释            | 备注                            |
| :----------------------- | :----- | :-------------- | :------------------------------ |
| user_id                  | int    | 用户ID          | -                               |
| songlists                | list   | 歌单列表        | -                               |
| songlists:songlist_id    | int    | 歌单ID          | -                               |
| songlists:songlist_title | string | 歌单名称        | -                               |
| songlists:description    | string | 歌单简介        | -                               |
| songlists:create_time    | string | 歌单创建时间    | 格式 yy-mm-dd hh:mm             |
| songlists:cover_url      | string | 歌单封面url地址 | -                               |
| songlists:like_count     | int    | 歌单点赞数量    | -                               |
| songlists:is_public      | bool   | 歌单公开性      | true表示公开，false表示个人私密 |
| total                    | int    | 歌单数量        | -                               |

```python
@csrf_exempt
def list_songlists(request):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再查看歌单"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 解析筛选参数
    # --------------------------
    is_public = request.GET.get("is_public")     # 可为 None / "1" / "0"
    sort_by = request.GET.get("sort_by", "create_time") # 默认按时间排序

    # --------------------------
    # 3. 构建 SQL
    # --------------------------
    sql = """
        SELECT songlist_id, songlist_title, description, create_time, cover_url, like_count, is_public
        FROM Songlist
        WHERE user_id = %s
    """

    params = [uid]

    # ---- 筛选公开性 ----
    if is_public in ["0", "1"]:
        sql += " AND is_public = %s"
        params.append(int(is_public))

    # ---- 排序 ----
    if sort_by == "likes":
        sql += " ORDER BY like_count DESC"
    else:
        sql += " ORDER BY create_time DESC"

    # --------------------------
    # 4. 执行 SQL 查询
    # --------------------------
    with connection.cursor() as cursor:
        cursor.execute(sql, params)
        rows = cursor.fetchall()

    # --------------------------
    # 5. 返回 JSON
    # --------------------------
    songlists = []
    for r in rows:
        sid, title, desc, ctime, cover, likes, public = r
        songlists.append({
            "songlist_id": sid,
            "songlist_title": title,
            "description": desc,
            "create_time": ctime.strftime("%Y-%m-%d %H:%M") if ctime else None,
            "cover_url": cover,
            "like_count": likes,
            "is_public": bool(public)
        })

    return json_cn({
        "user_id": uid,
        "songlists": songlists,
        "total": len(songlists)
    })
```

##### 创建歌单

- 路径 /create_songlist
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名         | 类型   | 可选 | 解释         | 备注                                     |
| -------------- | ------ | ---- | ------------ | ---------------------------------------- |
| songlist_title | string | -    | 歌单名称     | 必填                                     |
| description    | string | ✔    | 歌单简介     | -                                        |
| is_public      | int    | ✔    | 歌单公开性   | 1为公开，0为私密，默认为1                |
| cover_url      | string | ✔    | 封面图片路径 | 默认为/images/default_songlist_cover.jpg |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def create_songlist(request):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再创建歌单"}, 403)
    
    uid = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 接收数据并校验
    # --------------------------
    # 允许 JSON + Form 两种格式
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # ----------- 必填字段 -----------
    if "songlist_title" in data:
        songlist_title = data.get("songlist_title").strip()
    else:
        return json_cn({"error": "缺少歌单名称"}, 400)

    # ----------- 可选字段 + 默认值处理 -----------
    optional_fields = ["description", "is_public", "cover_url"]
    defaults = {
        "description": None,
        "is_public": 1,
        "cover_url": "/images/default_songlist_cover.jpg"
    }

    cleaned = {}
    for field in optional_fields:
        value = data.get(field, defaults[field])
        if value == "":
            value = defaults[field]
        cleaned[field] = value

    description = cleaned["description"]
    is_public = int(cleaned["is_public"])
    cover_url = cleaned["cover_url"]

    # --------------------------
    # 3. 正式创建歌单
    # --------------------------
    sql = """
        INSERT INTO Songlist (user_id, songlist_title, description, is_public, cover_url)
        VALUES (%s, %s, %s, %s, %s)
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [uid, songlist_title, description, is_public, cover_url])

    return json_cn({
        "message": f"成功创建歌单：{songlist_title}"
    })
```

##### 编辑歌单

- 路径 /edit_songlist/{songlist_id}/
- 方法 POST
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |

- 查询参数 无
- 请求体 表单数据

| 字段名         | 类型   | 可选 | 解释         | 备注 |
| -------------- | ------ | ---- | ------------ | ---- |
| songlist_title | string | -    | 歌单名称     | -    |
| description    | string | ✔    | 歌单简介     | -    |
| is_public      | int    | ✔    | 歌单公开性   | -    |
| cover_url      | string | ✔    | 封面图片路径 | -    |

- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| songlist_id | int    | 歌单ID   | -    |

```python
@csrf_exempt
def edit_songlist(request, songlist_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再编辑歌单"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 查询歌单是否存在 + 权限检查
    # --------------------------
    sql_select = """
        SELECT user_id, songlist_title, description, is_public, cover_url
        FROM Songlist
        WHERE songlist_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_select, [songlist_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "歌单不存在"}, 404)

    owner_id, old_title, old_desc, old_public, old_cover = row

    if owner_id != uid:
        return json_cn({"error": "无权限：你不是该歌单的创建者"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 3. POST：接收并校验数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # ----------- 必填字段 -----------
    if "songlist_title" in data:
        songlist_title = data.get("songlist_title").strip()
    else:
        return json_cn({"error": "修改失败：缺少歌单名称"}, 400)

    # ----------- 可选字段 -----------
    optional_fields = ["description", "is_public", "cover_url"]
    defaults = {
        "description": old_desc,
        "is_public": old_public,
        "cover_url": old_cover,
    }

    cleaned = {}
    for field in optional_fields:
        value = data.get(field, defaults[field])
        if value == "":
            value = defaults[field]
        cleaned[field] = value

    description = cleaned["description"]
    is_public = int(cleaned["is_public"])
    cover_url = cleaned["cover_url"]

    # --------------------------
    # 4. SQL 更新操作
    # --------------------------
    sql_update = """
        UPDATE Songlist
        SET songlist_title = %s, description = %s, is_public = %s, cover_url = %s
        WHERE songlist_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_update, [
            songlist_title, description, is_public, cover_url, songlist_id
        ])

    return json_cn({
        "message": f"歌单修改成功：{songlist_title}",
        "songlist_id": songlist_id
    })
```

##### 展示歌单详情

- 路径 /profile/{songlist_id}
- 方法 POST
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |

- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                   | 类型   | 解释                 | 备注                   |
| ------------------------ | ------ | -------------------- | ---------------------- |
| songlist_id              | int    | 歌单ID               | -                      |
| songlist_title           | string | 歌单名称             | -                      |
| description              | string | 歌单简介             | -                      |
| create_time              | string | 创建时间             | -                      |
| cover_url                | string | 封面路径             | -                      |
| like_count               | int    | 点赞数               | -                      |
| is_public                | bool   | 是否公开             | -                      |
| is_owner                 | bool   | 当前用户是否为创建者 | -                      |
| owner_id                 | int    | 创建者ID             | -                      |
| song_count               | int    | 歌曲总数             | -                      |
| total_duration           | int    | 总时长(秒)           | -                      |
| total_duration_formatted | string | 格式化总时长         | 格式 mm:ss             |
| songs                    | list   | 歌曲列表             | -                      |
| songs:song_id            | int    | 歌曲ID               | -                      |
| songs:song_title         | string | 歌曲名称             | -                      |
| songs:duration           | int    | 时长(秒)             | -                      |
| songs:album_title        | string | 专辑名称             | -                      |
| songs:singer_name        | string | 歌手名称             | -                      |
| comment_count            | int    | 评论总数             | -                      |
| comments                 | list   | 评论列表             | 包含评论内容及用户信息 |

```python
@csrf_exempt
def songlist_profile(request, songlist_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行查看操作"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 查询歌单信息
    # --------------------------
    sql_list = """
        SELECT user_id, songlist_title, description, create_time, cover_url,
               like_count, is_public
        FROM Songlist
        WHERE songlist_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_list, [songlist_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "歌单不存在"}, 404)

    owner_id, title, desc, ctime, cover, likes, is_public = row

    # --------------------------
    # 3. 私密歌单权限判断
    # --------------------------
    is_owner = (uid == owner_id)
    if not is_owner and is_public == 0:
        return json_cn({"error": "这是一个私密歌单，你无权查看"}, 403)

    # --------------------------
    # 4. 查询歌单中的歌曲列表
    # --------------------------
    sql_songs = """
        SELECT 
            s.song_id,
            s.song_title,
            s.duration,
            a.album_title AS album_title,
            sg.singer_id,
            sg.singer_name
        FROM Songlist_Song ss
        JOIN Song s ON ss.song_id = s.song_id
        JOIN Album a ON s.album_id = a.album_id
        JOIN Song_Singer ss2 ON s.song_id = ss2.song_id
        JOIN Singer sg ON ss2.singer_id = sg.singer_id
        WHERE ss.songlist_id = %s
        ORDER BY ss.add_time DESC
    """

    sql_comment = """
        SELECT 
            u.user_id, u.user_name, c.comment_id, c.content, c.like_count, c.comment_time
        FROM Comment c 
        JOIN User u ON u.user_id = c.user_id
        WHERE target_id = %s AND target_type = 'songlist'
        ORDER BY comment_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_songs, [songlist_id])
        song_rows = cursor.fetchall()

        cursor.execute(sql_comment, [songlist_id])
        comment_rows = cursor.fetchall()

    # --------------------------
    # 5. 计算总时长
    # --------------------------
    total_duration = sum([row[2] for row in song_rows])

    # --------------------------
    # 6. 生成歌曲列表
    # --------------------------
    songs = []
    for (sid, stitle, dur, album_title, singer_id, singer_name) in song_rows:
        songs.append({
            "song_id": sid,
            "song_title": stitle,
            "duration": dur,
            "duration_formatted": format_time(dur),
            "album_title": album_title,
            "singer_id": singer_id,
            "singer_name": singer_name
        })


    # --------------------------
    # 7. 生成歌单评论列表
    # --------------------------
    comments = []
    for user_id, user_name, comment_id, content, like_count, comment_time in comment_rows:
        comments.append({
            "comment_id": comment_id,
            "user_id": user_id,
            "user_name": user_name,
            "content": content,
            "like_count": like_count,
            "comment_time": comment_time.strftime("%Y-%m-%d %H:%M") if comment_time else None
        })

    # --------------------------
    # 8. 返回歌单详情
    # --------------------------
    return json_cn({
        "songlist_id": songlist_id,
        "songlist_title": title,
        "description": desc,
        "create_time": ctime.strftime("%Y-%m-%d %H:%M") if ctime else None,
        "cover_url": cover,
        "like_count": likes,
        "is_public": bool(is_public),
        "is_owner": is_owner,
        "owner_id": owner_id,
        "song_count": len(songs),
        "total_duration": total_duration,
        "total_duration_formatted": format_time(total_duration),
        "songs": songs,
        "comment_count": len(comments),
        "comments": comments
    })
```

##### 删除歌单

- 路径 /delete_songlist/{songlist_id}
- 方法 POST
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |

- 查询参数 无
- 请求体 无
- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| songlist_id | int    | 歌单ID   | -    |

```python
@csrf_exempt
def delete_songlist(request, songlist_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行删除操作"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 查询歌单是否存在 + 权限检查
    # --------------------------
    sql_select = """
        SELECT user_id, songlist_title
        FROM Songlist
        WHERE songlist_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_select, [songlist_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "删除失败：该歌单不存在"}, 404)

    owner_id, title = row

    if owner_id != uid:
        return json_cn({"error": "无权限删除：你不是该歌单的创建者"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 3. POST：执行删除
    # --------------------------
    sql_delete = """
        DELETE FROM Songlist
        WHERE songlist_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_delete, [songlist_id])

    return json_cn({
        "message": f"成功删除歌单：{title}",
        "songlist_id": songlist_id
    })
```

##### 向歌单插入歌曲

- 路径 /{songlist_id}/add_song/
- 方法 POST
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |

- 查询参数 无
- 请求体 表单数据

| 字段名  | 类型 | 可选 | 解释   | 备注 |
| ------- | ---- | ---- | ------ | ---- |
| song_id | int  | -    | 歌曲ID | -    |

- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| songlist_id | int    | 歌单ID   | -    |
| song_id     | int    | 歌曲ID   | -    |

```python
@csrf_exempt
def songlist_add_song(request, songlist_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再添加歌曲到歌单"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 查询歌单是否存在 + 权限检查
    # --------------------------
    sql_select = """
        SELECT user_id, songlist_title
        FROM Songlist
        WHERE songlist_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_select, [songlist_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "该歌单不存在"}, 404)

    owner_id, songlist_title = row

    if owner_id != uid:
        return json_cn({"error": "无权限：你不是该歌单的创建者"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 3. POST：接收并校验数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    if "song_id" not in data:
        return json_cn({"error": "添加失败：缺少 song_id"}, 400)

    try:
        song_id = int(data.get("song_id"))
    except:
        return json_cn({"error": "song_id 必须是数字"}, 400)

    # --------------------------
    # 4. 检查歌曲是否存在
    # --------------------------
    sql_check_song = "SELECT song_id, song_title FROM Song WHERE song_id = %s"
    with connection.cursor() as cursor:
        cursor.execute(sql_check_song, [song_id])
        song_row = cursor.fetchone()

    if not song_row:
        return json_cn({"error": f"歌曲不存在：ID = {song_id}"}, 404)

    song_title = song_row[1]

    # --------------------------
    # 5. 检查是否已在歌单中
    # --------------------------
    sql_check_exist = """
        SELECT 1 FROM Songlist_Song
        WHERE songlist_id = %s AND song_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_check_exist, [songlist_id, song_id])
        exists = cursor.fetchone()

    if exists:
        return json_cn({"error": f"添加失败：歌曲《{song_title}》已在歌单中"}, 400)

    # --------------------------
    # 6. SQL 插入关系记录
    # --------------------------
    sql_insert = """
        INSERT INTO Songlist_Song (songlist_id, song_id)
        VALUES (%s, %s)
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_insert, [songlist_id, song_id])

    return json_cn({
        "message": f"成功添加歌曲：{song_title}",
        "songlist_id": songlist_id,
        "song_id": song_id
    })
```

##### 删除歌单中的歌曲

- 路径 /{songlist_id}/delete_song/{song_id}/
- 方法 POST
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |
| song_id     | int  | 歌曲ID | -    |

- 查询参数 无
- 请求体 无
- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| songlist_id | int    | 歌单ID   | -    |
| song_id     | int    | 歌曲ID   | -    |

```python
@csrf_exempt
def songlist_delete_song(request, songlist_id, song_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行移除操作"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 查询歌单是否存在 + 权限检查
    # --------------------------
    sql_songlist = """
        SELECT user_id, songlist_title
        FROM Songlist
        WHERE songlist_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_songlist, [songlist_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "歌单不存在"}, 404)

    owner_id, songlist_title = row

    if owner_id != uid:
        return json_cn({"error": "无权限：你不是该歌单的创建者"}, 403)

    # --------------------------
    # 3. 查询歌曲是否存在 + 是否在歌单中
    # --------------------------
    sql_song = "SELECT song_title FROM Song WHERE song_id = %s"
    with connection.cursor() as cursor:
        cursor.execute(sql_song, [song_id])
        song_row = cursor.fetchone()

    if not song_row:
        return json_cn({"error": f"歌曲不存在：ID = {song_id}"}, 404)

    song_title = song_row[0]

    sql_check = """
        SELECT 1 FROM Songlist_Song
        WHERE songlist_id = %s AND song_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_check, [songlist_id, song_id])
        exists = cursor.fetchone()

    if not exists:
        return json_cn({"error": f"歌曲《{song_title}》不在该歌单中"}, 400)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 4. POST：执行删除
    # --------------------------
    sql_delete = """
        DELETE FROM Songlist_Song
        WHERE songlist_id = %s AND song_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_delete, [songlist_id, song_id])

    return json_cn({
        "message": f"已成功从歌单移除：{song_title}",
        "songlist_id": songlist_id,
        "song_id": song_id
    })
```

##### 对歌单中的歌曲排序

- 路径 /sort_songlist/{songlist_id}/
- 方法 GET
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |

- 查询参数

| 字段名 | 类型   | 可选 | 解释     | 备注                                     |
| ------ | ------ | ---- | -------- | ---------------------------------------- |
| sort   | string | ✔    | 排序方式 | 可选 add_time / duration / play_count 等 |

- 请求体 无
- 成功响应

| 字段名                   | 类型    | 解释               | 备注                |
| ------------------------ | ------- | ------------------ | ------------------- |
| songlist_id              | int     | 歌单ID             | -                   |
| songlist_title           | string  | 歌单名称           | -                   |
| sort_by                  | string  | 排序方式           | -                   |
| songs                    | list    | 歌曲列表           | -                   |
| songs:song_id            | int     | 歌曲ID             | -                   |
| songs:song_title         | stiring | 歌曲名称           | -                   |
| songs:duration           | int     | 歌曲时长           | -                   |
| songs:duration_formatted | string  | 格式化后的歌曲时长 | 格式 mm:ss          |
| songs:singer_id          | int     | 歌手ID             | -                   |
| songs:singer_name        | string  | 歌手名称           | -                   |
| songs:add_time           | string  | 歌曲添加时间       | 格式 yy-mm-dd hh:mm |
| total                    | int     | 歌曲总数           | -                   |

```python
@csrf_exempt
def sort_songlist(request, songlist_id):
    # --------------------------
    # 1. 检查登录状态
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录后再进行排序操作"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 查询歌单信息（获取权限）
    # --------------------------
    sql_info = """
        SELECT user_id, songlist_title, is_public
        FROM Songlist
        WHERE songlist_id = %s
    """
    with connection.cursor() as cursor:
        cursor.execute(sql_info, [songlist_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "歌单不存在"}, 404)

    owner_id, title, is_public = row

    # 私密歌单权限检查
    if is_public == 0 and uid != owner_id:
        return json_cn({"error": "无权查看私密歌单"}, 403)

    # --------------------------
    # 3. 获取排序方式（默认按添加时间）
    # --------------------------
    sort = request.GET.get("sort", "add_time")  # add_time / duration / play_count

    # 白名单，安全避免 SQL 注入
    sort_map = {
        "add_time": "ss.add_time DESC",
        "duration": "s.duration DESC",
        "play_count": "s.play_count DESC",
    }

    if sort not in sort_map:
        sort = "add_time"

    order_sql = sort_map[sort]

    # --------------------------
    # 4. 查询排序后的歌曲列表
    # --------------------------
    sql_songs = f"""
        SELECT 
            s.song_id,
            s.song_title,
            s.duration,
            a.album_title AS album_title,
            sg.singer_id,
            sg.singer_name,
            ss.add_time
        FROM Songlist_Song ss
        JOIN Song s ON ss.song_id = s.song_id
        JOIN Album a ON s.album_id = a.album_id
        JOIN Song_Singer ss2 ON s.song_id = ss2.song_id
        JOIN Singer sg ON ss2.singer_id = sg.singer_id
        WHERE ss.songlist_id = %s
        ORDER BY {order_sql}
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_songs, [songlist_id])
        rows = cursor.fetchall()

    # --------------------------
    # 5. 格式化返回数据
    # --------------------------
    songs = []
    for sid, name, duration, album, singer_id, singer_name, add_time in rows:
        songs.append({
            "song_id": sid,
            "song_title": name,
            "duration": duration,
            "duration_formatted": format_time(duration),
            "album_title": album,
            "singer_id": singer_id,
            "singer_name": singer_name,
            "add_time": add_time.strftime("%Y-%m-%d %H:%M") if add_time else None
        })

    # --------------------------
    # 6. 返回结果
    # --------------------------
    return json_cn({
        "songlist_id": songlist_id,
        "songlist_title": title,
        "sort_by": sort,
        "songs": songs,
        "total": len(songs)
    })
```

##### 搜索歌单

- 路径 /search_songlist
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 JSON/表单数据

| 字段名         | 类型   | 可选 | 解释     | 备注 |
| -------------- | ------ | ---- | -------- | ---- |
| songlist_title | string | ✔    | 歌单标题 | -    |

- 成功响应

| 字段名                 | 类型   | 解释     | 备注 |
| ---------------------- | ------ | -------- | ---- |
| total                  | int    | 总数     | -    |
| songlists              | list   | 歌单列表 | -    |
| songlists:songlist_id  | int    | 歌单ID   | -    |
| songlists:cover_url    | string | 封面URL  | -    |
| songlists:user_id      | int    | 创建者ID | -    |
| songlists:user_name    | string | 创建者名 | -    |
| songlists:songlist_tit | string | 歌单标题 | -    |

```python
@csrf_exempt
def search_songlist(request):
    # --------------------------
    # 1. 登录校验
    # --------------------------
    user_id = request.session.get("user_id")
    if not user_id:
        return json_cn({"error": "请先登录"}, 403)

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST    

        
    # --------------------------
    # 2. 获取搜索标签
    # --------------------------
    songlist_title = data.get("songlist_title", "").strip()

    filters = []
    params = []

    if songlist_title:
        filters.append("sl.songlist_title LIKE %s")
        params.append(f"%{songlist_title}%")


    # --------------------------
    # 3. 查询歌单信息
    # --------------------------
    sql_songlist = """
        SELECT sl.songlist_id, sl.songlist_title, sl.cover_url, u.user_id, u.user_name
        FROM Songlist sl
        JOIN User u ON u.user_id = sl.user_id
    """

    if filters:
        sql_songlist += " WHERE " + " AND ".join(filters)


    with connection.cursor() as cursor:
        cursor.execute(sql_songlist, params)
        rows = cursor.fetchall()

        if not rows:
            return json_cn({"message": "未找到符合歌单", "songlists": []})
            
        # --------------------------
        # 4. 返回搜索结果
        # --------------------------
        songlists = []
        for (songlist_id, songlist_title, cover_url, user_id, user_name) in rows:
            songlists.append({
                "songlist_id": songlist_id,
                "songlist_title": songlist_title,
                "cover_url": cover_url,
                "user_id": user_id,
                "user_name": user_name
            })

    return json_cn({
        "total": len(songlists),
        "songlists": songlists
    })
```

##### 点赞歌单

- 路径 /like_songlist/{songlist_id}
- 方法 POST/GET
- 路径参数

| 字段名      | 类型 | 解释   | 备注 |
| ----------- | ---- | ------ | ---- |
| songlist_id | int  | 歌单ID | -    |

- 查询参数 无
- 请求体 无
- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| songlist_id | int    | 歌单ID   | -    |

```python
@csrf_exempt
def like_songlist(request, songlist_id):
    sql = """
        UPDATE Songlist
        SET like_count = like_count + 1
        WHERE Songlist_id = %s;
    """

    with connection.cursor() as cursor:
        cursor.execute(sql, [songlist_id])

    return json_cn({
        "message": "点赞成功",
        "songlist_id": songlist_id
    })
```

##### 查看个人收藏

- 路径 /list_favorite
- 方法 POST/GET
- 路径参数 无
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                         | 类型   | 解释               | 备注                |
| ------------------------------ | ------ | ------------------ | ------------------- |
| user_id                        | int    | 用户ID             | -                   |
| songs                          | list   | 收藏歌曲           | -                   |
| songs:count                    | int    | 歌曲总数           | -                   |
| songs:total_duration           | int    | 总时长             | -                   |
| songs:items                    | list   | 歌曲列表           | -                   |
| songs:items:song_id            | int    | 歌曲ID             | -                   |
| songs:items:song_title         | string | 歌曲名称           | -                   |
| songs:items:duration           | int    | 歌曲时长           | -                   |
| songs:items:duration_formatted | string | 格式化后的歌曲时长 | 格式 mm:ss          |
| songs:items:favorite_time      | string | 收藏时间           | 格式 yy-mm-dd hh:mm |
| albums                         | list   | 收藏专辑           | -                   |
| albums:count                   | int    | 专辑总数           | -                   |
| albums:items                   | list   | 专辑列表           | -                   |
| albums:items:album_id          | int    | 专辑ID             | -                   |
| albums:items:album_title       | string | 专辑名称           | -                   |
| albums:items:release_date      | string | 发行日期           | -                   |
| albums:items:favorite_time     | string | 收藏时间           | 格式 yy-mm-dd hh:mm |
| songlists                      | list   | 收藏歌单           | -                   |
| songlists:count                | int    | 歌单总数           | -                   |
| songlists:items                | list   | 歌单列表           | -                   |
| songlists:items:songlist_id    | int    | 歌单ID             | -                   |
| songlists:items:songlist_title | string | 歌单名称           | -                   |
| songlists:items:favorite_time  | string | 收藏时间           | 格式 yy-mm-dd hh:mm |

```python
@csrf_exempt
def list_favorite(request):
    # --------------------------
    # 1. 必须登录
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再查看收藏"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 获取收藏的歌曲
    # --------------------------
    sql_song = """
        SELECT 
            s.song_id,
            s.song_title,
            s.duration,
            f.favorite_time
        FROM Favorite f
        JOIN Song s ON f.target_id = s.song_id
        WHERE f.user_id = %s AND f.target_type = 'song'
        ORDER BY f.favorite_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_song, [uid])
        songs = cursor.fetchall()

    song_count = len(songs)
    song_total_duration = sum([s[2] for s in songs]) if songs else 0


    # --------------------------
    # 3. 获取收藏的专辑
    # --------------------------
    sql_album = """
        SELECT 
            al.album_id,
            al.album_title,
            al.release_date,
            f.favorite_time
        FROM Favorite f
        JOIN Album al ON f.target_id = al.album_id
        WHERE f.user_id = %s AND f.target_type = 'album'
        ORDER BY f.favorite_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_album, [uid])
        albums = cursor.fetchall()

    album_count = len(albums)

    # --------------------------
    # 4. 获取收藏的歌单
    # --------------------------
    sql_songlist = """
        SELECT 
            sl.songlist_id,
            sl.songlist_title,
            f.favorite_time
        FROM Favorite f
        JOIN Songlist sl ON f.target_id = sl.songlist_id
        WHERE f.user_id = %s AND f.target_type = 'songlist'
        ORDER BY f.favorite_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_songlist, [uid])
        songlists = cursor.fetchall()

    songlist_count = len(songlists)

    # --------------------------
    # 5. 格式化返回数据
    # --------------------------

    # ---------- 收藏歌曲 ----------
    favorite_songs = []
    for sid, title, duration, ctime in songs:
        favorite_songs.append({
            "song_id": sid,
            "song_title": title,
            "duration": duration,
            "duration_formatted": format_time(duration),
            "favorite_time": ctime.strftime("%Y-%m-%d %H:%M") if ctime else None
        })

    # ---------- 收藏专辑 ----------
    favorite_albums = []
    for aid, title, date, ctime in albums:
        favorite_albums.append({
            "album_id": aid,
            "album_title": title,
            "release_date": str(date) if date else None,
            "favorite_time": ctime.strftime("%Y-%m-%d %H:%M") if ctime else None
        })

    # ---------- 收藏歌单 ----------
    favorite_songlists = []
    for lid, title, ctime in songlists:
        favorite_songlists.append({
            "songlist_id": lid,
            "songlist_title": title,
            "favorite_time": ctime.strftime("%Y-%m-%d %H:%M") if ctime else None
        })

    # ---------- 返回 ----------
    return json_cn({
        "user_id": uid,
        "songs": {
            "count": song_count,
            "total_duration": song_total_duration,
            "total_duration_formatted": format_time(song_total_duration),
            "items": favorite_songs
        },
        "albums": {
            "count": album_count,
            "items": favorite_albums
        },
        "songlists": {
            "count": songlist_count,
            "items": favorite_songlists
        }
    })
```

##### 进行收藏

- 路径 /add_favorite
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 

| 字段名 | 类型   | 解释         | 备注                  |
| ------ | ------ | ------------ | --------------------- |
| type   | string | 收藏对象类型 | song、album、songlist |
| id     | int    | 收藏对象ID   | -                     |

- 成功响应

| 字段名      | 类型   | 解释         | 备注                  |
| ----------- | ------ | ------------ | --------------------- |
| message     | string | 提示信息     | -                     |
| target_type | string | 收藏对象类型 | song、album、songlist |
| target_id   | int    | 收藏对象ID   | -                     |

```python
@csrf_exempt
def add_favorite(request):
    # --------------------------
    # 1. 必须登录
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再进行收藏"}, 403)

    uid = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    target_type = data.get("type")
    target_id = data.get("id")

    if target_type not in ["song", "album", "songlist"]:
        return json_cn({"error": "非法的收藏类型"}, 400)

    # --------------------------
    # 3. 检查是否已收藏
    # --------------------------
    sql_check = f"""
        SELECT 1
        FROM Favorite
        WHERE user_id = %s AND target_type = %s AND target_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [uid, target_type, target_id])
        exists = cursor.fetchone()

    if exists:
        return json_cn({"error": "已经收藏过了"}, 400)

    # --------------------------
    # 4. 插入收藏记录
    # --------------------------
    sql_insert = f"""
        INSERT INTO Favorite(user_id, target_type, target_id)
        VALUES(%s, %s, %s)
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_insert, [uid, target_type, target_id])

    # --------------------------
    # 5. 返回成功
    # --------------------------
    return json_cn({
        "message": "收藏成功",
        "target_type": target_type,
        "target_id": target_id
    })

```



##### 取消收藏

- 路径 /delete_favorite
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名 | 类型   | 可选 | 解释     | 备注                     |
| ------ | ------ | ---- | -------- | ------------------------ |
| type   | string | -    | 收藏类型 | song / album / songlist  |
| id     | int    | -    | 目标ID   | 歌曲ID / 专辑ID / 歌单ID |

- 成功响应

| 字段名      | 类型   | 解释     | 备注                     |
| ----------- | ------ | -------- | ------------------------ |
| message     | string | 提示信息 | -                        |
| target_type | string | 收藏类型 | song / album / songlist  |
| target_id   | int    | 目标ID   | 歌曲ID / 专辑ID / 歌单ID |

```python
@csrf_exempt
def delete_favorite(request):
    # --------------------------
    # 1. 检验登录
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再进行操作"}, 403)

    uid = request.session["user_id"]

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    target_type = data.get("type")
    target_id = data.get("id")

    if target_type not in ["song", "album", "songlist"]:
        return json_cn({"error": "非法的收藏类型"}, 400)

    # --------------------------
    # 3. 检查是否已收藏
    # --------------------------
    sql_check = f"""
        SELECT 1
        FROM Favorite
        WHERE user_id = %s AND target_type = %s AND target_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_check, [uid, target_type, target_id])
        exists = cursor.fetchone()

    if not exists:
        return json_cn({"error": "未收藏不能取消"}, 400)

    # --------------------------
    # 4. 删除收藏记录
    # --------------------------
    sql_delete = f"""
        DELETE FROM Favorite
        WHERE user_id = %s AND target_type = %s AND target_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_delete, [uid, target_type, target_id])

    # --------------------------
    # 5. 返回成功
    # --------------------------
    return json_cn({
        "message": "取消收藏成功",
        "target_type": target_type,
        "target_id": target_id
    })
```

##### "我收藏的歌曲" 统计

- 路径 /get_my_favorite_songs_stats
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                   | 类型     | 解释         | 备注       |
| ------------------------ | -------- | ------------ | ---------- |
| list_name                | string   | 列表名称     | -          |
| total_duration           | int      | 总时长       | -          |
| total_duration_formatted | string   | 格式化总时长 | 格式 mm:ss |
| count                    | int      | 歌曲数量     | -          |
| songs                    | list     | 歌曲列表     | -          |
| songs:song_id            | int      | 歌曲ID       | -          |
| songs:song_title         | string   | 歌曲名称     | -          |
| songs:duration           | int      | 歌曲时长     | -          |
| songs:play_count         | int      | 播放次数     | -          |
| songs:favorite_time      | datetime | 收藏时间     | -          |

```python
def get_my_favorite_songs_stats(request):
    """
    将用户收藏的歌曲视为一个"默认歌单"，返回列表和总时长
    """
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    current_user_id = request.session["user_id"]

    # 1. 计算收藏歌曲总时长
    sql_duration = """
        SELECT SUM(s.duration)
        FROM Favorite f
        JOIN Song s ON f.target_id = s.song_id
        WHERE f.user_id = %s
          AND f.target_type = 'song'
    """

    # 2. 获取歌曲列表
    sql_list = """
        SELECT s.song_id, s.song_title, s.duration, s.play_count, f.favorite_time
        FROM Favorite f
        JOIN Song s ON f.target_id = s.song_id
        WHERE f.user_id = %s
          AND f.target_type = 'song'
        ORDER BY f.favorite_time DESC
    """

    with connection.cursor() as cursor:
        # 总时长
        cursor.execute(sql_duration, [current_user_id])
        duration_row = cursor.fetchone()
        total_duration = duration_row[0] if duration_row and duration_row[0] else 0

        # 歌曲列表
        cursor.execute(sql_list, [current_user_id])
        songs = dictfetchall(cursor)

    return json_cn({
        "list_name": "我收藏的歌曲",
        "total_duration": total_duration,
        "total_duration_formatted": format_time(total_duration),
        "count": len(songs),
        "songs": songs
    })
```

##### 展示平台收藏排行榜

- 路径 /get_platform_top_favorites
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名      | 类型   | 可选 | 解释     | 备注                    |
| ----------- | ------ | ---- | -------- | ----------------------- |
| target_type | string | ✔    | 榜单类型 | song / album / songlist |
| limit       | int    | ✔    | 显示数量 | 默认为10                |

- 成功响应

| 字段名            | 类型   | 解释     | 备注                    |
| ----------------- | ------ | -------- | ----------------------- |
| type              | string | 榜单类型 | song / album / songlist |
| ranking           | list   | 排行列表 | -                       |
| ranking:target_id | int    | 目标ID   | -                       |
| ranking:fav_count | int    | 收藏总数 | -                       |
| ranking:name      | string | 名称     | -                       |

```python
def get_platform_top_favorites(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    if "user_id" not in request.session:
        return json_cn({"error": "请先登录"}, 403)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # type: 'song', 'album', 'songlist'
    target_type = data.get("target_type", "song")
    limit = data.get("limit", 10)  # 默认取前10

    if target_type == 'song':
        sql = """
            SELECT f.target_id, COUNT(*) as fav_count, s.song_title as name
            FROM Favorite f
            JOIN Song s ON f.target_id = s.song_id
            WHERE f.target_type = 'song'
            GROUP BY f.target_id, s.song_title
            ORDER BY fav_count DESC
            LIMIT %s
        """
    elif target_type == 'album':
        sql = """
            SELECT f.target_id, COUNT(*) as fav_count, a.album_title as name
            FROM Favorite f
            JOIN Album a ON f.target_id = a.album_id
            WHERE f.target_type = 'album'
            GROUP BY f.target_id, a.album_title
            ORDER BY fav_count DESC
            LIMIT %s
        """
    elif target_type == 'songlist':
        sql = """
            SELECT f.target_id, COUNT(*) as fav_count, sl.songlist_title as name
            FROM Favorite f
            JOIN Songlist sl ON f.target_id = sl.songlist_id
            WHERE f.target_type = 'songlist'
            GROUP BY f.target_id, sl.songlist_title
            ORDER BY fav_count DESC
            LIMIT %s
        """
    else:
        return json_cn({"error": "类型错误"}, 400)

    with connection.cursor() as cursor:
        cursor.execute(sql, [limit])
        result = dictfetchall(cursor)

    return json_cn({"ranking": result, "type": target_type})
```

#### 2.2.4 评论与互动模块

##### 根路由

/comment

##### 展示个人评论列表(按类型分组)

- 路径 /list_comment
- 方法 GET/POST
- 路径参数 无
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                       | 类型   | 解释       | 备注                |
| ---------------------------- | ------ | ---------- | ------------------- |
| user_id                      | int    | 用户ID     | -                   |
| songs                        | object | 歌曲评论组 | -                   |
| songs:count                  | int    | 评论数量   | -                   |
| songs:comments               | list   | 评论列表   | -                   |
| songs:comments:song_id       | int    | 评论歌曲ID | -                   |
| songs:comments:comment_id    | int    | 评论ID     | -                   |
| songs:comments:content       | string | 评论内容   | -                   |
| songs:comments:like_count    | int    | 评论点赞数 | -                   |
| songs:comments:comment_time  | string | 评论时间   | 格式 yy-mm-dd hh:mm |
| albums                       | object | 专辑评论组 | -                   |
| albums:count                 | int    | 评论数量   | -                   |
| albums:comments              | list   | 评论列表   | -                   |
| albums:comments:albums_id    | int    | 评论专辑ID | -                   |
| albums:comments:comment_id   | int    | 评论ID     | -                   |
| albums:comments:content      | string | 评论内容   | -                   |
| albums:comments:like_count   | int    | 评论点赞数 | -                   |
| albums:comments:comment_time | string | 评论时间   | 格式 yy-mm-dd hh:mm |
| songlists                    | object | 歌单评论组 | -                   |
| songlists:count              | int    | 评论数量   | -                   |
| songlists:comments           | list   | 评论列表   | -                   |
| albums:comments:songlist_id  | int    | 评论歌单ID | -                   |
| albums:comments:comment_id   | int    | 评论ID     | -                   |
| albums:comments:content      | string | 评论内容   | -                   |
| albums:comments:like_count   | int    | 评论点赞数 | -                   |
| albums:comments:comment_time | string | 评论时间   | 格式 yy-mm-dd hh:mm |

```python
@csrf_exempt
def list_comment(request):
    # --------------------------
    # 1. 必须登录
    # --------------------------
    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再查看评论"}, 403)

    uid = request.session["user_id"]

    # --------------------------
    # 2. 获取歌曲的评论
    # --------------------------
    sql_song = """
        SELECT 
            s.song_id,
            c.comment_id,
            c.content,
            c.like_count,
            c.comment_time
        FROM Comment c
        JOIN Song s ON s.song_id = c.target_id 
        WHERE c.user_id = %s AND c.target_type = 'song'
        ORDER BY c.comment_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_song, [uid])
        songs = cursor.fetchall()

    song_count = len(songs)

    # --------------------------
    # 3. 获取专辑的评论
    # --------------------------
    sql_album = """
        SELECT 
            a.album_id,
            c.comment_id,
            c.content,
            c.like_count,
            c.comment_time
        FROM Comment c
        JOIN Album a ON a.album_id = c.target_id
        WHERE c.user_id = %s AND c.target_type = 'album'
        ORDER BY c.comment_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_album, [uid])
        albums = cursor.fetchall()

    album_count = len(albums)

    # --------------------------
    # 4. 获取歌单的评论
    # --------------------------
    sql_songlist = """
        SELECT 
            sl.songlist_id,
            c.comment_id,
            c.content,
            c.like_count,
            c.comment_time
        FROM Comment c
        JOIN Songlist sl ON sl.songlist_id = c.target_id
        WHERE c.user_id = %s AND c.target_type = 'songlist'
        ORDER BY c.comment_time DESC
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_songlist, [uid])
        songlists = cursor.fetchall()

    songlist_count = len(songlists)

    # --------------------------
    # 5. 格式化返回数据
    # --------------------------

    # ---------- 歌曲评论 ----------
    song_comments = []
    for song_id, comment_id, content, like_count, comment_time in songs:
        song_comments.append({
            "song_id": song_id,
            "comment_id": comment_id,
            "content": content,
            "like_count": like_count,
            "comment_time": comment_time.strftime("%Y-%m-%d %H:%M") if comment_time else None
        })

    # ---------- 专辑评论 ----------
    album_comments = []
    for album_id, comment_id, content, like_count, comment_time in albums:
        album_comments.append({
            "album_id": album_id,
            "comment_id": comment_id,
            "content": content,
            "like_count": like_count,
            "comment_time": comment_time.strftime("%Y-%m-%d %H:%M") if comment_time else None
        })

    # ---------- 歌单评论 ----------
    songlist_comments = []
    for songlist_id, comment_id, content, like_count, comment_time in songlists:
        songlist_comments.append({
            "songlist_id": songlist_id,
            "comment_id": comment_id,
            "content": content,
            "like_count": like_count,
            "comment_time": comment_time.strftime("%Y-%m-%d %H:%M") if comment_time else None
        })

    # ---------- 返回 ----------
    return json_cn({
        "user_id": uid,
        "songs": {
            "count": song_count,
            "comments": song_comments
        },
        "albums": {
            "count": album_count,
            "comments": album_comments
        },
        "songlists": {
            "count": songlist_count,
            "comments": songlist_comments
        }
    })
```

##### 发布评论 / 回复评论

- 路径 /publish_comment
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名      | 类型   | 可选 | 解释         | 备注                    |
| ----------- | ------ | ---- | ------------ | ----------------------- |
| target_type | string | -    | 评论目标类型 | song / album / songlist |
| target_id   | int    | -    | 目标ID       | -                       |
| content     | string | -    | 评论内容     | -                       |
| parent_id   | int    | ✔    | 父评论ID     | 若为回复则填，否则不填  |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def publish_comment(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    # 必填参数
    target_type = data.get("target_type")  # song, album, songlist
    target_id = data.get("target_id")
    content = data.get("content")

    # 选填参数 (如果是回复别人的评论，则填 parent_id)
    parent_id = data.get("parent_id", None)

    if not all([target_type, target_id, content]):
        return json_cn({"error": "参数缺失: target_type, target_id, content"}, 400)

    if target_type not in ['song', 'album', 'songlist']:
        return json_cn({"error": "无效的评论目标类型"}, 400)

    # 简单的敏感词过滤逻辑可以在这里加...
    status = '审核中'

    sql = """
          INSERT INTO Comment (user_id, target_type, target_id, content, parent_id, status, like_count, comment_time)
          VALUES (%s, %s, %s, %s, %s, %s, 0, NOW()) \
          """

    with connection.cursor() as cursor:
        cursor.execute(sql, [current_user_id, target_type, target_id, content, parent_id, status])

    return json_cn({"message": "评论发布成功，正在进行安全审核"})
```

##### 删除评论 

- 路径 /delete_comment
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型 | 可选 | 解释   | 备注 |
| ---------- | ---- | ---- | ------ | ---- |
| comment_id | int  | -    | 评论ID | -    |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def delete_comment(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)
    comment_id = data.get("comment_id")

    if not comment_id:
        return json_cn({"error": "未检测到评论ID"}, 400)

    # 1. 检查评论是否存在以及归属信息
    sql_check = """
                SELECT user_id, target_type, target_id
                FROM Comment \
                WHERE comment_id = %s \
                """
    with connection.cursor() as cursor:
        cursor.execute(sql_check, [comment_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "评论不存在"}, 404)

    comment_owner_id, target_type, target_id = row

    can_delete = False

    # 情况A: 自己删自己的评论
    if str(comment_owner_id) == str(current_user_id):
        can_delete = True

    # 情况B: 管理自己创建的歌单下的评论
    # 如果这条评论是写在某个歌单下的(target_type='songlist')
    # 且这个歌单是当前用户创建的，那么他有权删除
    elif target_type == 'songlist':
        sql_check_songlist_owner = "SELECT 1 FROM Songlist WHERE songlist_id=%s AND user_id=%s"
        with connection.cursor() as cursor:
            cursor.execute(sql_check_songlist_owner, [target_id, current_user_id])
            if cursor.fetchone():
                can_delete = True

    if not can_delete:
        return json_cn({"error": "无权删除此评论"}, 403)

    # 执行删除
    # 级联删除
    def recursive_delete_comment(cursor, cid):
        """
        递归删除评论及其所有子评论
        """
        # 第一步：查找当前评论的所有子评论（回复）
        sql_find_children = "SELECT comment_id FROM Comment WHERE parent_id = %s"
        cursor.execute(sql_find_children, [cid])
        children = cursor.fetchall()

        # 第二步：对每一个子评论，递归调用删除
        for child in children:
            child_id = child[0]
            recursive_delete_comment(cursor, child_id)

        # 第三步：子孙都删完了，删除自己
        sql_delete_self = "DELETE FROM Comment WHERE comment_id = %s"
        cursor.execute(sql_delete_self, [cid])

    try:
        with connection.cursor() as cursor:
            # 调用递归函数
            recursive_delete_comment(cursor, comment_id)

        return json_cn({"message": "评论及其回复已成功删除"})

    except Exception as e:
        print(f"Delete Error: {e}")
        return json_cn({"error": "删除失败，数据库错误"}, 500)
```

##### 对评论进行点赞 / 举报

- 路径 /action_comment
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型   | 可选 | 解释     | 备注           |
| ---------- | ------ | ---- | -------- | -------------- |
| comment_id | int    | -    | 评论ID   | -              |
| action     | string | -    | 操作类型 | like 或 report |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def action_comment(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    comment_id = data.get("comment_id")
    action = data.get("action")  # 'like', 'report'

    if not comment_id or not action:
        return json_cn({"error": "参数缺失"}, 400)

    if action == 'like':
        # 只能直接增加计数
        sql = "UPDATE Comment SET like_count = like_count + 1 WHERE comment_id = %s"
        with connection.cursor() as cursor:
            cursor.execute(sql, [comment_id])
        return json_cn({"message": "点赞成功"})

    elif action == 'report':
        # 举报：将状态改为 '举报中'
        sql = "UPDATE Comment SET status = '举报中' WHERE comment_id = %s"
        with connection.cursor() as cursor:
            cursor.execute(sql, [comment_id])
        return json_cn({"message": "举报成功，等待管理员审核"})

    else:
        return json_cn({"error": "无效操作"}, 400)
```

##### 查看歌曲/专辑/歌单的评论列表 

- 路径 /get_comments_by_target
- 方法 GET
- 路径参数 无
- 查询参数

| 字段名      | 类型   | 可选 | 解释         | 备注                    |
| ----------- | ------ | ---- | ------------ | ----------------------- |
| target_type | string | -    | 评论目标类型 | song / album / songlist |
| target_id   | int    | -    | 目标ID       | -                       |
| sort_by     | string | ✔    | 排序方式     | time(默认) 或 hot       |

- 请求体 无
- 成功响应

| 字段名                | 类型     | 解释       | 备注 |
| --------------------- | -------- | ---------- | ---- |
| count                 | int      | 评论总数   | -    |
| comments              | list     | 评论列表   | -    |
| comments:comment_id   | int      | 评论ID     | -    |
| comments:content      | string   | 评论内容   | -    |
| comments:like_count   | int      | 点赞数     | -    |
| comments:comment_time | datetime | 评论时间   | -    |
| comments:user_name    | string   | 评论者昵称 | -    |
| comments:profile      | string   | 评论者简介 | -    |

##### 查看单条评论及其回复 

- 路径 /get_comment_detail
- 方法 GET
- 路径参数 无
- 查询参数

| 字段名     | 类型 | 可选 | 解释   | 备注 |
| ---------- | ---- | ---- | ------ | ---- |
| comment_id | int  | -    | 评论ID | -    |

- 请求体 无
- 成功响应

| 字段名  | 类型   | 解释       | 备注 |
| ------- | ------ | ---------- | ---- |
| comment | object | 主评论信息 | -    |
| replies | dict   | 回复列表   | -    |

```python
def get_comment_detail(request):
    if request.method != "GET":
        return json_cn({"error": "GET required"}, 400)

    comment_id = request.GET.get("comment_id")
    if not comment_id:
        return json_cn({"error": "未检测到评论ID"}, 400)

    with connection.cursor() as cursor:
        # 1. 获取主评论信息
        sql_main = """
                   SELECT c.comment_id, \
                          c.content, \
                          c.like_count, \
                          c.comment_time, \
                          c.user_id,
                          u.user_name, \
                          c.target_type, \
                          c.target_id
                   FROM Comment c
                            JOIN User u ON c.user_id = u.user_id
                   WHERE c.comment_id = %s \
                   """
        cursor.execute(sql_main, [comment_id])
        main_rows = dictfetchall(cursor)

        if not main_rows:
            return json_cn({"error": "评论不存在或已删除"}, 404)
        main_comment = main_rows[0]

        # 2. 获取该评论下的回复 (parent_id = comment_id)
        sql_replies = """
                      SELECT c.comment_id, \
                             c.content, \
                             c.like_count, \
                             c.comment_time, \
                             c.user_id,
                             u.user_name
                      FROM Comment c
                               JOIN User u ON c.user_id = u.user_id
                      WHERE c.parent_id = %s \
                        AND c.status = '正常'
                      ORDER BY c.comment_time ASC \
                      """
        cursor.execute(sql_replies, [comment_id])
        replies = dictfetchall(cursor)

    return json_cn({
        "comment": main_comment,
        "replies": replies
    })
```

##### 查看自己发布的评论

- 路径 /get_my_comments
- 方法 GET
- 路径参数 无
- 查询参数 无
- 请求体 无
- 成功响应

| 字段名                  | 类型   | 解释     | 备注                    |
| ----------------------- | ------ | -------- | ----------------------- |
| my_comments             | list   | 评论列表 | -                       |
| my_comments:target_type | string | 目标类型 | song / album / songlist |
| my_comments:target_id   | int    | 目标ID   | -                       |
| my_comments:content     | string | 评论内容 | -                       |
| my_comments:status      | string | 评论状态 | 正常 / 审核中 / 举报中  |

```python
def get_my_comments(request):
    if request.method != "GET":
        return json_cn({"error": "GET required"}, 400)

    # 登录验证需要 session，GET请求也能读 session
    current_user_id = request.session.get("user_id")
    if not current_user_id:
        return json_cn({"error": "请先登录"}, 401)

    sql = """
          SELECT comment_id, target_type, target_id, content, like_count, comment_time, status
          FROM Comment
          WHERE user_id = %s
          ORDER BY comment_time DESC \
          """

    with connection.cursor() as cursor:
        cursor.execute(sql, [current_user_id])
        comments = dictfetchall(cursor)

    return json_cn({"my_comments": comments})
```

##### 查看评论统计信息

- 路径 /get_comment_stats
- 方法 GET
- 路径参数 无
- 查询参数

| 字段名      | 类型   | 可选 | 解释     | 备注 |
| ----------- | ------ | ---- | -------- | ---- |
| target_type | string | -    | 目标类型 | -    |
| target_id   | int    | -    | 目标ID   | -    |

- 请求体 无
- 成功响应

| 字段名                 | 类型   | 解释       | 备注 |
| ---------------------- | ------ | ---------- | ---- |
| target_type            | string | 目标类型   | -    |
| target_id              | int    | 目标ID     | -    |
| total_comments         | int    | 评论总数   | -    |
| hot_comment            | object | 最热评论   | -    |
| hot_comment:content    | string | 最热评内容 | -    |
| hot_comment:user_name  | string | 评论者     | -    |
| hot_comment:like_count | int    | 点赞数     | -    |

##### 举报评论

- 路径 /report_comment
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型 | 可选 | 解释         | 备注 |
| ---------- | ---- | ---- | ------------ | ---- |
| comment_id | int  | -    | 被举报评论ID | -    |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def report_comment(request):

    if "user_id" not in request.session:
        return json_cn({"error": "请先登录再查看评论"}, 403)

    uid = request.session["user_id"]

    # 1. 获取参数
    data = json.loads(request.body)
    comment_id = data.get("comment_id")

    if not comment_id:
        return json_cn({"error": "参数缺失"}, 400)

    # 2. 执行举报
    # 逻辑：不管它之前是什么状态，只要有人举报，就改为 '举报中'，等待管理员处理
    sql = "UPDATE Comment SET status = '举报中' WHERE comment_id = %s"

    with connection.cursor() as cursor:
        cursor.execute(sql, [comment_id])

    return json_cn({"message": "举报成功，我们将尽快处理"})
```

#### 2.2.5 播放记录模块

##### 跟路由

/playHistory

##### 记录播放

- 路径 /record_play
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名        | 类型 | 可选 | 解释         | 备注     |
| ------------- | ---- | ---- | ------------ | -------- |
| song_id       | int  | -    | 歌曲ID       | -        |
| play_duration | int  | ✔    | 实际播放时长 | 默认为 0 |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def record_play(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    song_id = data.get("song_id")
    # 实际播放时长（秒），如果前端没传，默认0
    play_duration = data.get("play_duration", 0)

    if not song_id:
        return json_cn({"error": "未检测到歌曲ID"}, 400)

    with connection.cursor() as cursor:
        # 规则检查：防止重复记录 (Anti-Spam)
        # 检查该用户最近一次播放这首歌的时间
        sql_check_recent = """
                           SELECT play_time
                           FROM PlayHistory
                           WHERE user_id = %s \
                             AND song_id = %s
                           ORDER BY play_time DESC
                           LIMIT 1 \
                           """
        cursor.execute(sql_check_recent, [current_user_id, song_id])
        last_record = cursor.fetchone()

        should_record = True

        if last_record:
            last_time = last_record[0]
            # 获取当前时间 (注意时区问题，这里假设数据库和应用时区一致)
            # 如果最近一次播放是在 60秒 内，则认为是重复提交或者是切歌太快，不计入有效播放
            # 也可以根据 play_duration 判断，例如播放超过30秒才算
            now = datetime.datetime.now()
            if (now - last_time).total_seconds() < 60:
                should_record = False

        if should_record:
            # 1. 插入播放记录
            sql_insert = """
                         INSERT INTO PlayHistory (user_id, song_id, play_duration, play_time)
                         VALUES (%s, %s, %s, NOW()) \
                         """
            cursor.execute(sql_insert, [current_user_id, song_id, play_duration])

            # 2. 更新歌曲总播放次数 (原子更新)
            sql_update_song = """
                              UPDATE Song \
                              SET play_count = play_count + 1 \
                              WHERE song_id = %s \
                              """
            cursor.execute(sql_update_song, [song_id])

            return json_cn({"message": "播放记录已更新"})
        else:
            return json_cn({"message": "播放记录过频，忽略本次计数"})
```

##### 统计总播放次数 

- 路径 /playHistory/get_total_play_stats/
- 方法 GET
- 路径参数 无
- 查询参数

| 字段名      | 类型   | 可选 | 解释     | 备注                |
| ----------- | ------ | ---- | -------- | ------------------- |
| target_type | string | -    | 目标类型 | song, album, singer |
| target_id   | int    | -    | 目标ID   | -                   |

- 请求体 无
- 成功响应

| 字段名           | 类型   | 解释       | 备注 |
| ---------------- | ------ | ---------- | ---- |
| target_type      | string | 目标类型   | -    |
| target_id        | int    | 目标ID     | -    |
| total_play_count | int    | 总播放次数 | -    |

```python
def get_total_play_stats(request):
    if request.method != "GET":
        return json_cn({"error": "GET required"}, 400)

    target_type = request.GET.get("target_type")  # song, album, singer
    target_id = request.GET.get("target_id")

    if not target_type or not target_id:
        return json_cn({"error": "参数缺失"}, 400)

    count = 0
    with connection.cursor() as cursor:
        if target_type == 'song':
            # 直接查 Song 表
            sql = "SELECT play_count FROM Song WHERE song_id = %s"
            cursor.execute(sql, [target_id])
            row = cursor.fetchone()
            count = row[0] if row else 0

        elif target_type == 'album':
            # 统计该专辑下所有歌曲的播放数总和
            sql = """
                  SELECT SUM(play_count) \
                  FROM Song \
                  WHERE album_id = %s \
                  """
            cursor.execute(sql, [target_id])
            row = cursor.fetchone()
            count = row[0] if row and row[0] else 0

        elif target_type == 'singer':
            # 统计该歌手名下所有歌曲的播放数总和
            # 需要通过 Song_Singer 中间表关联 (或者 Song -> Album -> Singer)
            # 这里使用 Song_Singer 表更准确，因为包括了 feat 的歌曲
            sql = """
                  SELECT SUM(s.play_count)
                  FROM Song s
                           JOIN Song_Singer ss ON s.song_id = ss.song_id
                  WHERE ss.singer_id = %s \
                  """
            cursor.execute(sql, [target_id])
            row = cursor.fetchone()
            count = row[0] if row and row[0] else 0

        else:
            return json_cn({"error": "无效类型"}, 400)

    return json_cn({
        "target_type": target_type,
        "target_id": target_id,
        "total_play_count": count
    })
```

##### 用户查看播放记录 

- 路径 /get_my_play_history
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型   | 可选 | 解释       | 备注            |
| ---------- | ------ | ---- | ---------- | --------------- |
| start_date | string | ✔    | 开始日期   | 格式 YYYY-MM-DD |
| end_date   | string | ✔    | 结束日期   | 格式 YYYY-MM-DD |
| song_id    | int    | ✔    | 歌曲ID     | 若有则查单曲    |
| limit      | int    | ✔    | 记录条数限 | 默认为 50       |

- 成功响应

| 字段名                | 类型   | 解释            | 备注 |
| --------------------- | ------ | --------------- | ---- |
| count                 | int    | 记录总数        | -    |
| history               | list   | 历史记录列表    | -    |
| history:play_id       | int    | 播放记录ID      | -    |
| history:play_time     | string | 播放时间        | -    |
| history:play_duration | int    | 播放时长        | -    |
| history:song_id       | int    | 播放歌曲ID      | -    |
| history:song_title    | string | 歌曲名称        | -    |
| history:file_url      | string | 歌曲文件url地址 | -    |
| history:album_title   | string | 专辑名称        | -    |
| history:cover_url     | string | 专辑封面url地址 | -    |

```python
def get_my_play_history(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    # 筛选参数
    start_date = data.get("start_date")  # 格式 'YYYY-MM-DD'
    end_date = data.get("end_date")
    song_id = data.get("song_id")  # 如果传了这个，就是查看单曲的播放记录
    limit = data.get("limit", 50)  # 默认只看最近50条

    sql = """
          SELECT ph.play_id, \
                 ph.play_time, \
                 ph.play_duration,
                 s.song_id, \
                 s.song_title, \
                 s.file_url,
                 a.album_title, \
                 a.cover_url
          FROM PlayHistory ph
                   JOIN Song s ON ph.song_id = s.song_id
                   LEFT JOIN Album a ON s.album_id = a.album_id
          WHERE ph.user_id = %s \
          """
    params = [current_user_id]

    if start_date:
        sql += " AND ph.play_time >= %s"
        params.append(start_date)

    if end_date:
        # 结束日期通常要加一天或者到 23:59:59，这里简单处理
        sql += " AND ph.play_time <= %s"
        params.append(end_date + " 23:59:59")

    if song_id:
        sql += " AND ph.song_id = %s"
        params.append(song_id)

    sql += " ORDER BY ph.play_time DESC LIMIT %s"
    params.append(limit)

    with connection.cursor() as cursor:
        cursor.execute(sql, params)
        history = dictfetchall(cursor)

    return json_cn({"history": history, "count": len(history)})
```

##### 生成用户播放报告 

- 路径 /get_play_report
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型   | 可选 | 解释     | 备注                                       |
| ---------- | ------ | ---- | -------- | ------------------------------------------ |
| time_range | string | ✔    | 时间范围 | week, month, self-defined<br />默认为 week |
| start_date | string | ✔    | 开始日期 | 仅当 self-defined 时需提供                 |
| end_date   | string | ✔    | 结束日期 | 仅当 self-defined 时需提供                 |

- 成功响应

| 字段名                        | 类型   | 解释         | 备注   |
| ----------------------------- | ------ | ------------ | ------ |
| time_range                    | string | 时间范围类型 | -      |
| report                        | object | 报告内容     | -      |
| report:total_plays            | int    | 总播放次数   | -      |
| report:total_duration_minutes | float  | 总播放时长   | (分钟) |
| report:top_song               | object | 最常听的歌曲 | -      |
| report:top_song:song_title    | string | 歌曲名称     | -      |
| report:top_song:play_times    | int    | 歌曲播放次数 | -      |

```python
def get_play_report(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    # time_range: 'week', 'month', 'all'
    time_range = data.get("time_range", "week")

    # 构建时间条件
    sql_where = "WHERE user_id = %s"
    params = [current_user_id]

    if time_range == 'week':
        # 最近7天
        sql_where += " AND play_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)"
    elif time_range == 'month':
        # 最近30天
        sql_where += " AND play_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)"
    elif time_range == 'self-defined':
        if "start_date" in data:
            sql_where += " AND play_time >= %s"
            params.append(data.get("start_date"))
        if "end_date" in data:
            sql_where += " AND play_time <= %s"
            params.append(data.get("end_date"))

    with connection.cursor() as cursor:
        # 1. 统计总次数和总时长
        sql_summary = f"""
            SELECT COUNT(*) as total_count, SUM(play_duration) as total_seconds
            FROM PlayHistory
            {sql_where}
        """
        cursor.execute(sql_summary, params)
        summary = dictfetchall(cursor)[0]

        # 处理 None 的情况
        if not summary['total_seconds']: summary['total_seconds'] = 0

        # 2. 统计该时间段内听得最多的歌 (Top 1)
        sql_top_song = f"""
            SELECT s.song_title, COUNT(ph.song_id) as play_times
            FROM PlayHistory ph
            JOIN Song s ON ph.song_id = s.song_id
            {sql_where.replace('WHERE', 'WHERE ph.')} 
            GROUP BY ph.song_id, s.song_title
            ORDER BY play_times DESC
            LIMIT 1
        """
        # 注意：这里 user_id 参数需要再传一遍，或者稍微调整 SQL 拼接逻辑
        # 为简单起见，这里复用 params
        cursor.execute(sql_top_song, params)
        top_song_row = dictfetchall(cursor)
        top_song = top_song_row[0] if top_song_row else None

    return json_cn({
        "time_range": time_range,
        "report": {
            "total_plays": summary['total_count'],
            "total_duration_minutes": round(summary['total_seconds'] / 60, 2),
            "top_song": top_song
        }
    })
```

##### 展示用户最常听排行榜

- 路径 /get_user_top_charts
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名 | 类型   | 可选 | 解释     | 备注                |
| ------ | ------ | ---- | -------- | ------------------- |
| type   | string | ✔    | 榜单类型 | song, singer, album |
| limit  | int    | ✔    | 显示数量 | 默认为 10           |

- 成功响应

| 字段名             | 类型   | 解释     | 备注                          |
| ------------------ | ------ | -------- | ----------------------------- |
| chart_type         | string | 榜单类型 | -                             |
| list               | list   | 排行列表 | -                             |
| list:my_play_count | int    | 播放次数 | -                             |
| list:{type}_title  | string | 名称     | type可以为song, singer, album |
| list:{type}_id     | int    | ID       | type可以为song, singer, album |

```python
def get_user_top_charts(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    # type: 'song', 'singer', 'album'
    chart_type = data.get("type", "song")
    limit = data.get("limit", 10)

    with connection.cursor() as cursor:
        if chart_type == 'song':
            sql = """
                  SELECT s.song_id, s.song_title, s.file_url, COUNT(*) as my_play_count
                  FROM PlayHistory ph
                           JOIN Song s ON ph.song_id = s.song_id
                  WHERE ph.user_id = %s
                  GROUP BY s.song_id, s.song_title, s.file_url
                  ORDER BY my_play_count DESC
                  LIMIT %s \
                  """
            cursor.execute(sql, [current_user_id, limit])

        elif chart_type == 'album':
            sql = """
                  SELECT a.album_id, a.album_title, a.cover_url, COUNT(*) as my_play_count
                  FROM PlayHistory ph
                           JOIN Song s ON ph.song_id = s.song_id
                           JOIN Album a ON s.album_id = a.album_id
                  WHERE ph.user_id = %s
                  GROUP BY a.album_id, a.album_title, a.cover_url
                  ORDER BY my_play_count DESC
                  LIMIT %s \
                  """
            cursor.execute(sql, [current_user_id, limit])

        elif chart_type == 'singer':
            # 这里需要关联 Song -> SongSinger -> Singer
            sql = """
                  SELECT singer.singer_id, singer.singer_name, COUNT(*) as my_play_count
                  FROM PlayHistory ph
                           JOIN Song s ON ph.song_id = s.song_id
                           JOIN Song_Singer ss ON s.song_id = ss.song_id
                           JOIN Singer singer ON ss.singer_id = singer.singer_id
                  WHERE ph.user_id = %s
                  GROUP BY singer.singer_id, singer.singer_name
                  ORDER BY my_play_count DESC
                  LIMIT %s \
                  """
            cursor.execute(sql, [current_user_id, limit])

        else:
            return json_cn({"error": "无效的榜单类型"}, 400)

        result = dictfetchall(cursor)

    return json_cn({
        "chart_type": chart_type,
        "list": result
    })
```

##### 用户时间段内播放情况统计 (趋势图数据) 

- 路径 /get_user_activity_trend
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名 | 类型   | 可选 | 解释     | 备注       |
| ------ | ------ | ---- | -------- | ---------- |
| period | string | ✔    | 统计周期 | day, month |

- 成功响应

| 字段名           | 类型   | 解释     | 备注       |
| ---------------- | ------ | -------- | ---------- |
| period           | string | 统计周期 | -          |
| trend            | list   | 趋势数据 | -          |
| trend:date_str   | string | 日期字符 | 格式 yy-mm |
| trend:play_count | int    | 播放次数 | -          |

```python
def get_user_activity_trend(request):
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    current_user_id = get_user_id(request)
    data = json.loads(request.body)

    # period: 'day' (最近14天, 按天统计), 'month' (最近12个月, 按月统计)
    period = data.get("period", "day")

    with connection.cursor() as cursor:
        if period == 'day':
            # 按日期分组统计
            sql = """
                  SELECT DATE_FORMAT(play_time, '%%Y-%%m-%%d') as date_str, COUNT(*) as play_count
                  FROM PlayHistory
                  WHERE user_id = %s \
                    AND play_time >= DATE_SUB(NOW(), INTERVAL 14 DAY)
                  GROUP BY date_str
                  ORDER BY date_str ASC \
                  """
        elif period == 'month':
            # 按月份分组统计
            sql = """
                  SELECT DATE_FORMAT(play_time, '%%Y-%%m') as date_str, COUNT(*) as play_count
                  FROM PlayHistory
                  WHERE user_id = %s \
                    AND play_time >= DATE_SUB(NOW(), INTERVAL 12 MONTH)
                  GROUP BY date_str
                  ORDER BY date_str ASC \
                  """
        else:
            return json_cn({"error": "Invalid period"}, 400)

        # 注意：Python 中 % 是占位符，所以在 SQL 里的 %Y 需要写成 %%Y 进行转义
        cursor.execute(sql, [current_user_id])
        trend_data = dictfetchall(cursor)

    return json_cn({
        "period": period,
        "trend": trend_data
    })
```

#### 2.2.6 管理员管理模块

##### 根路由

/Administrator

##### 新增歌手

- 路径 /singer/admin_add_singer
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名       | 类型   | 可选 | 解释     | 备注               |
| ------------ | ------ | ---- | -------- | ------------------ |
| singer_name  | string | -    | 歌手名称 | -                  |
| type         | string | -    | 歌手类型 | '男', '女', '组合' |
| country      | string | ✔    | 国籍     | -                  |
| birthday     | string | ✔    | 出生日期 | 格式 YYYY-MM-DD    |
| introduction | string | ✔    | 简介     | -                  |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def admin_add_singer(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp
    
    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取歌手数据并校验
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    if "singer_name" in data:
        singer_name = data.get("singer_name")
    else:
        return json_cn({"error": "未检测到歌手名称"}, 400)
    

    if "type" in data:
        singer_type = data.get("type")     
    else:
        return json_cn({"error": "错误歌手类别"}, 400)

    # -------- 可选字段，但要处理默认值 -------- 
    # 需要处理的所有可选字段
    optional_fields = ["country", "birthday", "introduction"]

    # 默认值
    defaults = {
        "country": None,
        "birthday": None,
        "introduction": None,
    }

    # 解析字段
    cleaned = {}
    for field in optional_fields:
        value = data.get(field, defaults[field])
        if value == "":
            value = defaults[field]
        cleaned[field] = value

    # 获得最终值
    country = cleaned["country"]
    birthday = cleaned["birthday"]
    introduction = cleaned["introduction"]


    # --------------------------
    # 3. 正式添加歌手
    # --------------------------
    sql = """
        INSERT 
        INTO Singer (singer_name, type, country, birthday, introduction)
        VALUES(%s, %s, %s, %s, %s)
    """

    try:
        with connection.cursor() as cursor:
            cursor.execute(sql, [
                singer_name, singer_type, country, birthday, introduction
                ])
            # 获取新 ID
            cursor.execute("SELECT LAST_INSERT_ID()")
            new_singer_id = cursor.fetchone()[0]

        add_system_log(
            action=f"新增歌手: {singer_name}",
            target_table="Singer",
            target_id=new_singer_id,
            result="success"
        )

        return json_cn({"message": f"成功添加歌手：{singer_name}"})
    except Exception as e:
        add_system_log(
            action=f"新增歌手失败: {singer_name}",
            target_table="Singer",
            target_id=None,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 删除歌手

- 路径 /singer/admin_delete_singer
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名      | 类型   | 可选 | 解释     | 备注     |
| ----------- | ------ | ---- | -------- | -------- |
| singer_id   | int    | -    | 歌手ID   | -        |
| singer_name | string | -    | 歌手名称 | 二次校验 |

- 成功响应

| 字段名      | 类型   | 解释             | 备注 |
| ----------- | ------ | ---------------- | ---- |
| message     | string | 提示信息         | -    |
| singer_id   | int    | 被删除的歌手ID   | -    |
| singer_name | string | 被删除的歌手名称 | -    |

```python
@csrf_exempt
def admin_delete_singer(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取歌手id并校验
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST   


    if "singer_id" in data:
        singer_id = data.get("singer_id")
    else:
        return json_cn({"error": "未检测到歌手id"}, 400)
    
    if "singer_name" in data:
        singer_name = data.get("singer_name")
    else:
        return json_cn({"error": "未检测到歌手名字"}, 400)
    
    # --------------------------
    # 3. 检验歌手名字
    # --------------------------
    name_sql = """
        SELECT singer_name
        FROM Singer 
        WHERE singer_id = %s      
    """
    with connection.cursor() as cursor:
        cursor.execute(name_sql, [singer_id])
        row = cursor.fetchone()
    
    if row is None:
        return json_cn({"error": "歌手不存在"}, 404)
    elif singer_name != row[0]:
        return json_cn({"error": "歌手名与要删除的歌手不匹配"}, 400)

    # --------------------------
    # 4. 删除对应歌手
    # --------------------------

    delete_sql = """
        DELETE 
        FROM Singer 
        WHERE singer_id = %s   
    """

    try:
        with connection.cursor() as cursor:
            cursor.execute(delete_sql, [singer_id])

        add_system_log(
            action=f"删除歌手: {singer_name}",
            target_table="Singer",
            target_id=singer_id,
            result="success"
        )

        return json_cn({
            "message": "歌手删除成功",
            "singer_id": singer_id,
            "singer_name": singer_name
        })
    except Exception as e:
        add_system_log(
            action=f"删除歌手失败: {singer_name}",
            target_table="Singer",
            target_id=singer_id,
            result="fail"
        )

    return json_cn({"error": str(e)}, 500)
```

##### 修改歌手信息（名称、类型、国籍、生日和简介）

- 路径 /singer/admin_update_singer
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名       | 类型   | 可选 | 解释     | 备注               |
| ------------ | ------ | ---- | -------- | ------------------ |
| singer_id    | int    | -    | 歌手ID   | -                  |
| singer_name  | string | ✔    | 歌手名称 | -                  |
| type         | string | ✔    | 歌手类型 | '男', '女', '组合' |
| country      | string | ✔    | 国籍     | -                  |
| birthday     | string | ✔    | 出生日期 | -                  |
| introduction | string | ✔    | 简介     | -                  |

- 成功响应

| 字段名         | 类型   | 解释       | 备注 |
| -------------- | ------ | ---------- | ---- |
| message        | string | 提示信息   | -    |
| singer_id      | int    | 歌手ID     | -    |
| original_name  | string | 原名       | -    |
| updated_fields | list   | 已更新字段 | -    |

```python
@csrf_exempt
def admin_update_singer(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 3. 校验 singer_id (必须存在)
    # --------------------------
    if "singer_id" in data:
        singer_id = data.get("singer_id")
    else:
        return json_cn({"error": "未检测到歌手id"}, 400)

    # 先检查数据库中是否有这个人
    check_sql = "SELECT singer_name FROM Singer WHERE singer_id = %s"
    with connection.cursor() as cursor:
        cursor.execute(check_sql, [singer_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "该歌手不存在"}, 404)

    old_name = row[0]  # 用于返回提示

    # --------------------------
    # 4. 动态构建 UPDATE 语句
    # --------------------------
    # 定义允许修改的字段
    allowed_fields = ["singer_name", "type", "country", "birthday", "introduction"]

    update_clauses = []  # 存 "field = %s"
    params = []  # 存具体的值

    for field in allowed_fields:
        # 只有当前端传了这个字段时，才去更新它
        if field in data:
            value = data.get(field)

            # 特殊处理：如果前端传空字符串给可空的字段，视为将其设为 NULL
            if field in ["country", "birthday", "introduction"] and value == "":
                value = None

            update_clauses.append(f"{field} = %s")
            params.append(value)

    # 如果没有任何字段需要更新
    if not update_clauses:
        return json_cn({"error": "未检测到任何需要修改的字段"}, 400)

    # 拼接 SQL: UPDATE Singer SET field1=%s, field2=%s WHERE singer_id=%s
    sql = f"UPDATE Singer SET {', '.join(update_clauses)} WHERE singer_id = %s"

    # 把 ID 加到参数列表的最后，对应 WHERE 子句
    params.append(singer_id)

    # --------------------------
    # 5. 执行更新
    # --------------------------
    try:
        with connection.cursor() as cursor:
            cursor.execute(sql, params)

        add_system_log(
            action=f"成功修改歌手信息: {old_name}",
            target_table="Singer",
            target_id=singer_id,
            result="success"
        )

        return json_cn({
            "message": "歌手信息修改成功",
            "singer_id": singer_id,
            "original_name": old_name,
            "updated_fields": [k for k in data.keys() if k in allowed_fields]
        })

    except Exception as e:
        add_system_log(
            action=f"修改歌手信息失败: {old_name}",
            target_table="Singer",
            target_id=singer_id,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 新增专辑

- 路径 /album/admin_add_album
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名       | 类型   | 可选 | 解释     | 备注                                   |
| ------------ | ------ | ---- | -------- | -------------------------------------- |
| album_title  | string | -    | 专辑名称 | -                                      |
| singer_id    | int    | -    | 歌手ID   | -                                      |
| release_date | string | ✔    | 发行日期 | 默认为 1970-01-01                      |
| cover_url    | string | ✔    | 封面路径 | 默认为 /images/default_album_cover.jpg |
| description  | string | ✔    | 专辑简介 | -                                      |

- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| album_title | string | 专辑名称 | -    |
| singer_name | string | 歌手名称 | -    |

```python
@csrf_exempt
def admin_add_album(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 2. 获取专辑数据并校验
    # --------------------------
    if "album_title" in data:
        album_title = data.get("album_title")
    else:
        return json_cn({"error": "未检测到专辑名称"}, 400)
    
    if "singer_id" in data:
        singer_id = data.get("singer_id")
    else:
        return json_cn({"error": "未检测到歌手id"}, 400)
    
    sql_singer = """
        SELECT singer_name FROM Singer WHERE singer_id = %s
    """

    with connection.cursor() as cursor:
        cursor.execute(sql_singer, [singer_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "歌手不存在"}, 404)
    else: 
        singer_name = row[0]


    # -------- 可选字段，但要处理默认值 -------- 
    # 需要处理的所有可选字段
    optional_fields = ["release_date", "cover_url", "description"]

    # 默认值
    defaults = {
        "release_date": "1970-01-01",
        "cover_url": "/images/default_album_cover.jpg",
        "description": None,
    }

    # 解析字段
    cleaned = {}
    for field in optional_fields:
        value = data.get(field, defaults[field])
        if value == "":
            value = defaults[field]
        cleaned[field] = value

    # 获得最终值
    release_date = cleaned["release_date"]
    cover_url = cleaned["cover_url"]
    description = cleaned["description"]


    # --------------------------
    # 3. 正式添加专辑
    # --------------------------

    sql = """
        INSERT INTO Album (album_title, singer_id, release_date, cover_url, description)
        VALUES (%s, %s, %s, %s, %s)
    """

    try:
        with connection.cursor() as cursor:
            cursor.execute(sql, [
                album_title, singer_id, release_date, cover_url, description,
                ])
            # 获取新 ID
            cursor.execute("SELECT LAST_INSERT_ID()")
            new_album_id = cursor.fetchone()[0]

        add_system_log(
            action=f"新增专辑: {album_title}",
            target_table="Album",
            target_id=new_album_id,
            result="success"
        )

        return json_cn({
            "message": "专辑已添加",
            "album_title": album_title,
            "singer_name": singer_name
        })

    except Exception as e:
        add_system_log(
            action=f"添加专辑失败: {album_title}",
            target_table="Album",
            target_id=None,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 删除专辑

- 路径 /album/admin_delete_album
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名   | 类型 | 可选 | 解释   | 备注 |
| -------- | ---- | ---- | ------ | ---- |
| album_id | int  | -    | 专辑ID | -    |

- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| album_id    | int    | 专辑ID   | -    |
| album_title | string | 专辑名称 | -    |

```python
@csrf_exempt
def admin_delete_album(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST


    # --------------------------
    # 2. 获取要删除的专辑数据
    # --------------------------
    if "album_id" in data:
        album_id = data.get("album_id")
    else:
        return json_cn({"error": "未检测到专辑id"}, 400)

    # --------------------------
    # 3. 获取专辑标题
    # --------------------------
    name_sql = """
        SELECT album_title
        FROM Album 
        WHERE album_id = %s      
    """
    with connection.cursor() as cursor:
        cursor.execute(name_sql, [album_id])
        row = cursor.fetchone()
    
    if row is None:
        return json_cn({"error": "专辑不存在"}, 404)
    
    album_title = row[0]

    # --------------------------
    # 4. 正式删除专辑
    # --------------------------
    sql = "DELETE FROM Album WHERE album_id = %s"

    try:
        with connection.cursor() as cursor:
            cursor.execute(sql, [album_id])

        add_system_log(
            action=f"删除专辑: {album_title}",
            target_table="Album",
            target_id=album_id,
            result="success"
        )

        return json_cn({
            "message": "专辑已删除",
            "album_id": album_id,
            "album_title": album_title
        })

    except Exception as e:
        add_system_log(
            action=f"删除专辑失败: {album_title}",
            target_table="Album",
            target_id=album_id,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 修改专辑信息（名称、歌手、发行日期、url地址和解释信息）

- 路径 /album/admin_update_album
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名       | 类型   | 可选 | 解释     | 备注                   |
| ------------ | ------ | ---- | -------- | ---------------------- |
| album_id     | int    | -    | 专辑ID   | -                      |
| album_title  | string | ✔    | 专辑名称 | 可选字段一定要存在一项 |
| singer_id    | int    | ✔    | 歌手ID   | 可选字段一定要存在一项 |
| release_date | string | ✔    | 发行日期 | 可选字段一定要存在一项 |
| cover_url    | string | ✔    | 封面路径 | 可选字段一定要存在一项 |
| description  | string | ✔    | 简介     | 可选字段一定要存在一项 |

- 成功响应

| 字段名         | 类型   | 解释       | 备注 |
| -------------- | ------ | ---------- | ---- |
| message        | string | 提示信息   | -    |
| album_id       | int    | 专辑ID     | -    |
| original_name  | string | 原名       | -    |
| updated_fields | list   | 已更新字段 | -    |

```python
@csrf_exempt
def admin_update_album(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 3. 校验 album_id (必须存在)
    # --------------------------
    if "album_id" in data:
        album_id = data.get("album_id")
    else:
        return json_cn({"error": "未检测到专辑id"}, 400)

    # 先检查数据库中是否有这张专辑
    check_sql = "SELECT album_title FROM Album WHERE album_id = %s"
    with connection.cursor() as cursor:
        cursor.execute(check_sql, [album_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "该专辑不存在"}, 404)

    old_title = row[0]  # 用于返回提示

    # --------------------------
    # 4. 动态构建 UPDATE 语句
    # --------------------------
    # 定义允许修改的字段
    allowed_fields = ["album_title", "singer_id", "release_date", "cover_url", "description"]

    update_clauses = []  # 存 "field = %s"
    params = []  # 存具体的值

    for field in allowed_fields:
        # 只有当前端传了这个字段时，才去更新它
        if field in data:
            value = data.get(field)

            # 特殊处理：如果前端传空字符串给可空的字段，视为将其设为 NULL
            if field in ["description"] and value == "":
                value = None

            # 特殊处理：如果前端传空字符串给不可空但是有默认值的字段，视为设为默认值
            if field in ["release_date", "cover_url"] and value == "":
                if field == "release_date":
                    value = '1970-01-01'
                elif field == "cover_url":
                    value = '/images/default_album_cover.jpg'

            # 特殊判断：外键一定要存在
            if field in ["singer_id"]:
                check_singer_sql = "SELECT singer_name FROM Singer WHERE singer_id = %s"
                with connection.cursor() as cursor:
                    cursor.execute(check_singer_sql, [value])
                    row = cursor.fetchone()

                if not row:
                    return json_cn({"error": "修改信息中的歌手不存在"}, 404)

            update_clauses.append(f"{field} = %s")
            params.append(value)

    # 如果没有任何字段需要更新
    if not update_clauses:
        return json_cn({"error": "未检测到任何需要修改的字段"}, 400)

    # 拼接 SQL: UPDATE Album SET field1=%s, field2=%s WHERE album_id=%s
    sql = f"UPDATE Album SET {', '.join(update_clauses)} WHERE album_id = %s"

    # 把 ID 加到参数列表的最后，对应 WHERE 子句
    params.append(album_id)

    # --------------------------
    # 5. 执行更新
    # --------------------------
    try:
        with connection.cursor() as cursor:
            cursor.execute(sql, params)

        add_system_log(
            action=f"成功修改专辑信息: {old_title}",
            target_table="Album",
            target_id=album_id,
            result="success"
        )

        return json_cn({
            "message": "专辑信息修改成功",
            "album_id": album_id,
            "original_name": old_title,
            "updated_fields": [k for k in data.keys() if k in allowed_fields]
        })
    except Exception as e:
        add_system_log(
            action=f"修改专辑信息失败: {old_title}",
            target_table="Album",
            target_id=album_id,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 添加歌曲

- 路径 /song/admin_add_song
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型     | 可选 | 解释         | 备注                   |
| ---------- | -------- | ---- | ------------ | ---------------------- |
| song_title | string   | -    | 歌曲名称     | -                      |
| album_id   | int      | -    | 所属专辑ID   | -                      |
| duration   | string   | -    | 歌曲时长     | 支持格式 mm:ss 或 m:ss |
| file_url   | string   | -    | 文件路径     | -                      |
| singers_id | int/list | -    | 关联歌手ID表 | 可传单个或列表         |

- 成功响应

| 字段名     | 类型   | 解释       | 备注 |
| ---------- | ------ | ---------- | ---- |
| message    | string | 提示信息   | -    |
| song_title | string | 歌曲名称   | -    |
| song_id    | int    | 歌曲ID     | -    |
| singers_id | string | 关联歌手ID | -    |

```python
@csrf_exempt
def admin_add_song(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST


    # --------------------------
    # 2. 获取歌曲数据并校验
    # --------------------------
    if "song_title" in data:
        song_title = data.get("song_title")
    else:
        return json_cn({"error": "未检测到歌曲名称"}, 400)
    
    if "album_id" in data:
        album_id = data.get("album_id")
    else:
        return json_cn({"error": "未检测到所属专辑id"}, 400)
    
    if "duration" in data:
        try:
            # 支持 mm:ss 或 m:ss
            minutes, seconds = map(int, data.get("duration").strip().split(":"))
            duration_seconds = minutes * 60 + seconds
        except Exception:
            return json_cn({"error": "歌曲时长格式错误，应为 mm:ss"}, 400)
    else:
        return json_cn({"error": "未检测到歌曲时长"}, 400)
    
    if "file_url" in data:
        file_url = data.get("file_url")
    else:
        return json_cn({"error": "未检测到歌曲文件路径"}, 400)


    # --------------------------
    # 3. 获取歌曲-歌手关系
    # --------------------------
    # 获取 singers_id
    if "singers_id" in data:
        singers_id = data.get("singers_id")
    else:
        return json_cn({"error": "未检测到歌曲的歌手id"}, 400)
    
    # 不是列表则自动改成单元素列表
    if not isinstance(singers_id, list):
        singers_id = [singers_id]


    # --------------------------
    # 4. 正式添加歌曲
    # --------------------------
    try:
        sql_insert_song = """
            INSERT INTO Song (song_title, album_id, duration, file_url)
            VALUES (%s, %s, %s, %s)
        """

        with connection.cursor() as cursor:
            cursor.execute(sql_insert_song, [
                song_title, album_id, duration_seconds, file_url
                ])

            # 获取新插入的 song_id
            cursor.execute("SELECT LAST_INSERT_ID()")
            song_id = cursor.fetchone()[0]


        # 插入多对多关系
        sql_insert_m2m = """
            INSERT INTO Song_Singer (song_id, singer_id)
            VALUES (%s, %s)
        """

        with connection.cursor() as cursor:
            for singer_id in singers_id:
                cursor.execute(sql_insert_m2m, [song_id, singer_id])

        singers_str = ", ".join(str(sid) for sid in singers_id)

        add_system_log(
            action=f"新增歌曲: {song_title}",
            target_table="Song",
            target_id=song_id,
            result="success"
        )

        return json_cn({
            "message": "歌曲已添加",
            "song_title": song_title,
            "song_id": song_id,
            "singers_id": singers_str
        })

    except Exception as e:
        add_system_log(
            action=f"添加歌曲失败: {song_title}",
            target_table="Song",
            target_id=None,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 删除歌曲

- 路径 /song/admin_delete_song
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名  | 类型 | 可选 | 解释   | 备注 |
| ------- | ---- | ---- | ------ | ---- |
| song_id | int  | -    | 歌曲ID | -    |

- 成功响应

| 字段名      | 类型   | 解释     | 备注 |
| ----------- | ------ | -------- | ---- |
| message     | string | 提示信息 | -    |
| song_title  | string | 歌曲名称 | -    |
| album_title | string | 专辑名称 | -    |
| singers     | string | 歌手列表 | -    |

```python
@csrf_exempt
def admin_delete_song(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    if "song_id" not in data:
        return json_cn({"error": "未检测到要删除的歌曲id"}, 400)
    else:
        song_id = data.get("song_id")


    # --------------------------
    # 2. 获取歌曲名、所属专辑和歌手
    # --------------------------
    sql_song = """
        SELECT s.song_title, a.album_title
        FROM Song s
        JOIN Album a ON a.album_id = s.album_id
        WHERE s.song_id = %s
    """

    sql_singers = """
        SELECT si.singer_name
        FROM Singer si
        JOIN Song_Singer ss ON si.singer_id = ss.singer_id
        WHERE ss.song_id = %s
    """

    with connection.cursor() as cursor:

        # 查询歌曲 + 专辑
        cursor.execute(sql_song, [song_id])
        song_row = cursor.fetchone()

        if not song_row:
            return json_cn({"error": "要删除的歌曲不存在"}, 404)
        
        song_title, album_title = song_row

        # 查询歌手列表
        cursor.execute(sql_singers, [song_id])
        singer_rows = cursor.fetchall()
        singers = [row[0] for row in singer_rows]
        singers_str = ", ".join(str(sid) for sid in singers)



    # --------------------------
    # 3. 正式删除歌曲
    # --------------------------
    try:
        # 先删除外键
        sql_delete_Song_Singer = "DELETE FROM Song_Singer WHERE song_id = %s"

        # 再删除本体
        sql_delete_Song = "DELETE FROM Song WHERE song_id=%s"

        with connection.cursor() as cursor:
            cursor.execute(sql_delete_Song_Singer, [song_id])
            cursor.execute(sql_delete_Song, [song_id])

        add_system_log(
            action=f"删除歌曲: {song_title}",
            target_table="Song",
            target_id=song_id,
            result="success"
        )

        return json_cn({
            "message": "歌曲已删除",
            "song_title": song_title,
            "album_title": album_title,
            "singers": singers_str
        })

    except Exception as e:
        add_system_log(
            action=f"添加歌曲失败: {song_title}",
            target_table="Song",
            target_id=song_id,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 修改歌曲信息（歌曲名、专辑信息、持续时间、url地址和播放次数）

- 路径 /song/admin_update_song
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型   | 可选 | 解释     | 备注                   |
| ---------- | ------ | ---- | -------- | ---------------------- |
| song_id    | int    | -    | 歌曲ID   | -                      |
| song_title | string | ✔    | 歌曲名称 | 可选字段一定要存在一项 |
| album_id   | int    | ✔    | 专辑ID   | 可选字段一定要存在一项 |
| duration   | int    | ✔    | 时长(秒) | 可选字段一定要存在一项 |
| file_url   | string | ✔    | 文件路径 | 可选字段一定要存在一项 |
| play_count | int    | ✔    | 播放次数 | 可选字段一定要存在一项 |

- 成功响应

| 字段名         | 类型   | 解释       | 备注 |
| -------------- | ------ | ---------- | ---- |
| message        | string | 提示信息   | -    |
| song_id        | int    | 歌曲ID     | -    |
| original_name  | string | 原名       | -    |
| updated_fields | list   | 已更新字段 | -    |

```python
@csrf_exempt
def admin_update_song(request):
    # --------------------------
    # 1. 检查管理员状态
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取数据
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        data = request.POST

    # --------------------------
    # 3. 校验 song_id (必须存在)
    # --------------------------
    if "song_id" in data:
        song_id = data.get("song_id")
    else:
        return json_cn({"error": "未检测到歌曲id"}, 400)

    # 先检查数据库中是否有这首歌曲
    check_sql = "SELECT song_title FROM Song WHERE song_id = %s"
    with connection.cursor() as cursor:
        cursor.execute(check_sql, [song_id])
        row = cursor.fetchone()

    if not row:
        return json_cn({"error": "该歌曲不存在"}, 404)

    old_title = row[0]  # 用于返回提示

    # --------------------------
    # 4. 动态构建 UPDATE 语句
    # --------------------------
    # 定义允许修改的字段
    allowed_fields = ["song_title", "album_id", "duration", "file_url", "play_count"]

    update_clauses = []  # 存 "field = %s"
    params = []  # 存具体的值

    for field in allowed_fields:
        # 只有当前端传了这个字段时，才去更新它
        if field in data:
            value = data.get(field)

            # 特殊处理：如果前端传空字符串给不可空但是有默认值的字段，视为设为默认值
            if field in ["play_count"] and value == "":
                if field == "play_count":
                    value = 0

            # 特殊判断：外键一定要存在
            if field in ["album_id"]:
                check_album_sql = "SELECT album_title FROM Album WHERE album_id = %s"
                with connection.cursor() as cursor:
                    cursor.execute(check_album_sql, [value])
                    row = cursor.fetchone()

                if not row:
                    return json_cn({"error": "修改信息中的专辑不存在"}, 404)

            update_clauses.append(f"{field} = %s")
            params.append(value)

    # 如果没有任何字段需要更新
    if not update_clauses:
        return json_cn({"error": "未检测到任何需要修改的字段"}, 400)

    # 拼接 SQL: UPDATE Song SET field1=%s, field2=%s WHERE song_id=%s
    sql = f"UPDATE Song SET {', '.join(update_clauses)} WHERE song_id = %s"

    # 把 ID 加到参数列表的最后，对应 WHERE 子句
    params.append(song_id)

    # --------------------------
    # 5. 执行更新
    # --------------------------
    try:
        with connection.cursor() as cursor:
            cursor.execute(sql, params)

        add_system_log(
            action=f"修改歌曲信息成功: {old_title}",
            target_table="Song",
            target_id=song_id,
            result="success"
        )

        return json_cn({
            "message": "歌曲信息修改成功",
            "song_id": song_id,
            "original_name": old_title,
            "updated_fields": [k for k in data.keys() if k in allowed_fields]
        })

    except Exception as e:
        add_system_log(
            action=f"修改歌曲信息失败: {old_title}",
            target_table="Song",
            target_id=song_id,
            result="fail"
        )

        return json_cn({"error": str(e)}, 500)
```

##### 查看系统日志

- 路径 /get_system_logs/
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名       | 类型   | 可选 | 解释       | 备注           |
| ------------ | ------ | ---- | ---------- | -------------- |
| target_table | string | ✔    | 目标表名   | -              |
| result       | string | ✔    | 操作结果   | success / fail |
| keyword      | string | ✔    | 搜索关键字 | -              |
| page         | int    | ✔    | 页码       | 默认1          |
| page_size    | int    | ✔    | 每页数量   | 默认20         |

- 成功响应

| 字段名                  | 类型   | 解释         | 备注 |
| ----------------------- | ------ | ------------ | ---- |
| data                    | list   | 日志列表     | -    |
| pagination              | object | 分页信息     | -    |
| pagination:current_page | int    | 当前页面编号 | -    |
| pagination:page_size    | int    | 页面大小     | -    |
| pagination:total_count  | int    | 日志总数     | -    |
| pagination:total_pages  | int    | 页面数量     | -    |

```python
@csrf_exempt
def get_system_logs(request):
    # --------------------------
    # 1. 权限检查
    # --------------------------
    ok, resp = require_admin(request)
    if not ok:
        return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    # --------------------------
    # 2. 获取参数
    # --------------------------
    try:
        data = json.loads(request.body)
    except:
        return json_cn({"error": "JSON format error"}, 400)

    # 筛选条件
    filter_table = data.get("target_table")  # e.g., 'Singer'
    filter_result = data.get("result")  # e.g., 'fail'
    keyword = data.get("keyword")  # e.g., '删除'

    # 分页参数
    page = int(data.get("page", 1))
    page_size = int(data.get("page_size", 20))
    offset = (page - 1) * page_size

    # --------------------------
    # 3. 构建复用的 SQL 片段
    # --------------------------

    # base_sql: 存储 FROM 和 WHERE 部分，供 Count 和 Select 共用
    base_sql_parts = ["FROM SystemLog"]
    where_clauses = ["WHERE 1=1"]  # 使用 1=1 方便后续直接 append 'AND ...'
    base_params = []  # 存储筛选条件的参数

    # 3.1 拼接筛选条件
    if filter_table:
        where_clauses.append("AND target_table = %s")
        base_params.append(filter_table)

    if filter_result:
        where_clauses.append("AND result = %s")
        base_params.append(filter_result)

    if keyword:
        where_clauses.append("AND action LIKE %s")
        base_params.append(f"%{keyword}%")

    # 3.2 组合成完整的公共部分
    # 结果类似: "FROM SystemLog WHERE 1=1 AND target_table = %s AND action LIKE %s"
    common_sql_suffix = f"{base_sql_parts[0]} {' '.join(where_clauses)}"

    # --------------------------
    # 4. 执行数据库查询
    # --------------------------
    with connection.cursor() as cursor:

        # ====================
        # 第一查：统计总数 (Count)
        # ====================
        # 拼接: SELECT COUNT(*) + 公共后缀
        sql_count = f"SELECT COUNT(*) {common_sql_suffix}"

        cursor.execute(sql_count, base_params)  # 直接使用 base_params
        total_count = cursor.fetchone()[0]

        # ====================
        # 第二查：获取数据 (Select)
        # ====================
        # 拼接: SELECT 字段... + 公共后缀 + ORDER BY + LIMIT
        sql_data = f"""
            SELECT log_id, action, target_table, target_id, action_time, result
            {common_sql_suffix}
            ORDER BY action_time DESC
            LIMIT %s OFFSET %s
        """

        # 构造 Select 专用的参数列表：筛选参数 + 分页参数
        # 注意：这里必须是 base_params + [...]，顺序不能乱
        data_params = base_params + [page_size, offset]

        cursor.execute(sql_data, data_params)
        logs = dictfetchall(cursor)

    # --------------------------
    # 5. 返回结果
    # --------------------------
    return json_cn({
        "data": logs,
        "pagination": {
            "current_page": page,
            "page_size": page_size,
            "total_count": total_count,
            "total_pages": (total_count + page_size - 1) // page_size
        }
    })
```

##### 获取用户行为统计

- 路径 /user/get_user_behavior_stats/
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型   | 可选 | 解释     | 备注       |
| ---------- | ------ | ---- | -------- | ---------- |
| start_date | string | ✔    | 开始日期 | YYYY-MM-DD |
| end_date   | string | ✔    | 结束日期 | YYYY-MM-DD |

- 成功响应

| 字段名           | 类型   | 解释         | 备注                     |
| ---------------- | ------ | ------------ | ------------------------ |
| summary          | object | 数据概览     | 新增用户、播放等总量     |
| trends           | object | 每日趋势     | 播放、新增用户、互动趋势 |
| top_active_users | list   | 活跃用户排行 | 前10名                   |

```python
@csrf_exempt
def get_user_behavior_stats(request):
    # 1. 权限检查
    ok, resp = require_admin(request)
    if not ok: return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        return json_cn({"error": "JSON format error"}, 400)

    # 2. 获取时间范围参数
    # 默认查看最近 7 天
    today = datetime.date.today()
    seven_days_ago = today - datetime.timedelta(days=7)

    start_date = data.get("start_date", str(seven_days_ago))  # 'YYYY-MM-DD'
    end_date = data.get("end_date", str(today))

    # 构造 SQL 用的时间范围 (加上时间后缀以覆盖全天)
    start_dt = f"{start_date} 00:00:00"
    end_dt = f"{end_date} 23:59:59"

    stats_data = {}

    with connection.cursor() as cursor:

        # -------------------------------------------------
        # Part A: 数据概览 (Dashboard Summary)
        # 统计该时间段内的总量
        # -------------------------------------------------
        sql_summary = """
                      SELECT (SELECT COUNT(*) FROM User WHERE register_time BETWEEN %s AND %s)     as new_users, \
                             (SELECT COUNT(*) FROM PlayHistory WHERE play_time BETWEEN %s AND %s)  as total_plays, \
                             (SELECT COUNT(*) FROM Comment WHERE comment_time BETWEEN %s AND %s)   as total_comments, \
                             (SELECT COUNT(*) FROM Favorite WHERE favorite_time BETWEEN %s AND %s) as total_favorites, \
                             (SELECT COUNT(*) FROM Songlist WHERE create_time BETWEEN %s AND %s)   as new_songlists \
                      """
        # 参数需要重复填入，因为有5个子查询，每个都需要 start_dt, end_dt
        params_summary = [start_dt, end_dt] * 5

        cursor.execute(sql_summary, params_summary)
        summary_row = dictfetchall(cursor)[0]
        stats_data['summary'] = summary_row

        # -------------------------------------------------
        # Part B: 每日趋势 (Daily Trend)
        # 用于前端画折线图: x轴是日期, y轴是数量
        # -------------------------------------------------

        # 1. 每日播放量
        sql_trend_play = """
                         SELECT DATE_FORMAT(play_time, '%%Y-%%m-%%d') as date_str, COUNT(*) as count
                         FROM PlayHistory
                         WHERE play_time BETWEEN %s AND %s
                         GROUP BY date_str \
                         ORDER BY date_str \
                         """
        cursor.execute(sql_trend_play, [start_dt, end_dt])
        trend_play = dictfetchall(cursor)

        # 2. 每日新增用户
        sql_trend_user = """
                         SELECT DATE_FORMAT(register_time, '%%Y-%%m-%%d') as date_str, COUNT(*) as count
                         FROM User
                         WHERE register_time BETWEEN %s AND %s
                         GROUP BY date_str \
                         ORDER BY date_str \
                         """
        cursor.execute(sql_trend_user, [start_dt, end_dt])
        trend_user = dictfetchall(cursor)

        # 3. 每日互动 (评论+收藏)
        # 这里演示如何将两个表的统计合并 (Union All 然后 Sum)
        sql_trend_interaction = """
                                SELECT date_str, SUM(cnt) as count \
                                FROM (SELECT DATE_FORMAT(comment_time, '%%Y-%%m-%%d') as date_str, COUNT(*) as cnt \
                                      FROM Comment \
                                      WHERE comment_time BETWEEN %s AND %s \
                                      GROUP BY date_str \
                                      UNION ALL \
                                      SELECT DATE_FORMAT(favorite_time, '%%Y-%%m-%%d') as date_str, COUNT(*) as cnt \
                                      FROM Favorite \
                                      WHERE favorite_time BETWEEN %s AND %s \
                                      GROUP BY date_str) as temp_table
                                GROUP BY date_str \
                                ORDER BY date_str \
                                """
        cursor.execute(sql_trend_interaction, [start_dt, end_dt, start_dt, end_dt])
        trend_interaction = dictfetchall(cursor)

        stats_data['trends'] = {
            "plays": trend_play,
            "new_users": trend_user,
            "interactions": trend_interaction
        }

        # -------------------------------------------------
        # Part C: 活跃用户排行 (Top Active Users)
        # 找出这段时间内听歌最多的前10名用户
        # -------------------------------------------------
        sql_top_users = """
                        SELECT u.user_id, u.user_name, u.email, COUNT(ph.play_id) as play_count
                        FROM PlayHistory ph
                                 JOIN User u ON ph.user_id = u.user_id
                        WHERE ph.play_time BETWEEN %s AND %s
                        GROUP BY u.user_id, u.user_name, u.email
                        ORDER BY play_count DESC
                        LIMIT 10 \
                        """
        cursor.execute(sql_top_users, [start_dt, end_dt])
        top_users = dictfetchall(cursor)

        stats_data['top_active_users'] = top_users



    return json_cn(stats_data)
```

##### 获取特定用户的详细行为统计 (用户画像)

- 路径 /user/get_specific_user_stats
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名         | 类型   | 可选 | 解释       | 备注 |
| -------------- | ------ | ---- | ---------- | ---- |
| target_user_id | int    | -    | 目标用户ID | -    |
| start_date     | string | ✔    | 开始日期   | -    |
| end_date       | string | ✔    | 结束日期   | -    |

- 成功响应

| 字段名           | 类型   | 解释         | 备注 |
| ---------------- | ------ | ------------ | ---- |
| user_info        | object | 用户基本信息 | -    |
| behavior_summary | object | 行为数据概览 | -    |
| top_artist       | object | 最常听歌手   | -    |
| peak_hour        | int    | 活跃时段     | 0-23 |
| daily_trend      | list   | 每日活跃趋势 | -    |
| social_stats     | object | 社交数据     | -    |

```python
@csrf_exempt
def get_specific_user_stats(request):
    # 1. 权限检查 (管理员可以看任何人，或者用户看自己)
    # 这里假设是管理员接口
    ok, resp = require_admin(request)
    if not ok: return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    try:
        data = json.loads(request.body)
    except:
        return json_cn({"error": "JSON format error"}, 400)

    # 2. 获取参数
    target_user_id = data.get("target_user_id")
    if not target_user_id:
        return json_cn({"error": "未指定目标用户ID (target_user_id)"}, 400)

    # 时间范围 (默认最近 30 天)
    today = datetime.date.today()
    thirty_days_ago = today - datetime.timedelta(days=30)

    start_date = data.get("start_date", str(thirty_days_ago))
    end_date = data.get("end_date", str(today))

    start_dt = f"{start_date} 00:00:00"
    end_dt = f"{end_date} 23:59:59"

    stats = {}

    with connection.cursor() as cursor:

        # -------------------------------------------------
        # Part 0: 用户基本信息确认
        # -------------------------------------------------
        sql_user_info = "SELECT user_name, email, register_time, status FROM User WHERE user_id = %s"
        cursor.execute(sql_user_info, [target_user_id])
        user_info = dictfetchall(cursor)
        if not user_info:
            return json_cn({"error": "用户不存在"}, 404)
        stats['user_info'] = user_info[0]

        # -------------------------------------------------
        # Part A: 行为概览 (Summary)
        # 统计该时间段内的各项核心指标
        # -------------------------------------------------
        # 使用 COALESCE 确保 SUM 返回 0 而不是 None
        sql_summary = """
                      SELECT (SELECT COUNT(*) \
                              FROM PlayHistory \
                              WHERE user_id = %s AND play_time BETWEEN %s AND %s)                                   as play_count, \
                             (SELECT COALESCE(SUM(play_duration), 0) \
                              FROM PlayHistory \
                              WHERE user_id = %s \
                                AND play_time BETWEEN %s AND %s)                                                    as total_duration_sec, \
                             (SELECT COUNT(*) \
                              FROM Comment \
                              WHERE user_id = %s \
                                AND comment_time BETWEEN %s AND %s)                                                 as comment_count, \
                             (SELECT COUNT(*) \
                              FROM Favorite \
                              WHERE user_id = %s \
                                AND favorite_time BETWEEN %s AND %s)                                                as favorite_count, \
                             (SELECT COUNT(*) \
                              FROM Songlist \
                              WHERE user_id = %s \
                                AND create_time BETWEEN %s AND %s)                                                  as songlist_created \
                      """
        # 参数顺序对应 SQL 中的 %s
        params_summary = [
            target_user_id, start_dt, end_dt,  # Play Count
            target_user_id, start_dt, end_dt,  # Duration
            target_user_id, start_dt, end_dt,  # Comment
            target_user_id, start_dt, end_dt,  # Favorite
            target_user_id, start_dt, end_dt  # Songlist
        ]

        cursor.execute(sql_summary, params_summary)
        stats['behavior_summary'] = dictfetchall(cursor)[0]

        # 转换一下时长显示 (分钟)
        total_sec = stats['behavior_summary']['total_duration_sec']
        stats['behavior_summary']['total_duration_min'] = round(total_sec / 60, 1)

        # -------------------------------------------------
        # Part B: 听歌偏好 (Preferences)
        # -------------------------------------------------

        # 1. 最常听的歌手 (Top Artist)
        # 关联路径: PlayHistory -> Song -> Song_Singer -> Singer
        sql_top_singer = """
                         SELECT s.singer_name, s.type, COUNT(*) as listen_count
                         FROM PlayHistory ph
                                  JOIN Song_Singer ss ON ph.song_id = ss.song_id
                                  JOIN Singer s ON ss.singer_id = s.singer_id
                         WHERE ph.user_id = %s \
                           AND ph.play_time BETWEEN %s AND %s
                         GROUP BY s.singer_id, s.singer_name, s.type
                         ORDER BY listen_count DESC
                         LIMIT 1 \
                         """
        cursor.execute(sql_top_singer, [target_user_id, start_dt, end_dt])
        top_singer_data = dictfetchall(cursor)
        stats['top_artist'] = top_singer_data[0] if top_singer_data else None

        # 2. 听歌时间分布 (比如：深夜党还是白日党)
        # 统计播放发生在哪个小时段 (0-23)
        sql_active_hour = """
                          SELECT HOUR(play_time) as hour_of_day, COUNT(*) as count
                          FROM PlayHistory
                          WHERE user_id = %s \
                            AND play_time BETWEEN %s AND %s
                          GROUP BY hour_of_day
                          ORDER BY count DESC
                          LIMIT 1 \
                          """
        cursor.execute(sql_active_hour, [target_user_id, start_dt, end_dt])
        hour_data = dictfetchall(cursor)
        stats['peak_hour'] = hour_data[0]['hour_of_day'] if hour_data else None

        # -------------------------------------------------
        # Part C: 每日活跃趋势 (Activity Trend)
        # 用于生成该用户的活跃度折线图
        # -------------------------------------------------
        sql_trend = """
                    SELECT DATE_FORMAT(play_time, '%%Y-%%m-%%d') as date_str,
                           COUNT(*)                              as plays,
                           SUM(play_duration)                    as duration
                    FROM PlayHistory
                    WHERE user_id = %s \
                      AND play_time BETWEEN %s AND %s
                    GROUP BY date_str
                    ORDER BY date_str ASC \
                    """
        cursor.execute(sql_trend, [target_user_id, start_dt, end_dt])
        stats['daily_trend'] = dictfetchall(cursor)

        # -------------------------------------------------
        # Part D: 社交影响力 (Social)
        # 统计粉丝数和关注数 (截止到目前，不限时间段，因为这是累积数据)
        # -------------------------------------------------
        sql_social = """
                     SELECT (SELECT COUNT(*) FROM UserFollow WHERE follower_id = %s) as following_count, \
                            (SELECT COUNT(*) FROM UserFollow WHERE followed_id = %s) as followers_count \
                     """
        cursor.execute(sql_social, [target_user_id, target_user_id])
        stats['social_stats'] = dictfetchall(cursor)[0]

    return json_cn(stats)
```

##### 获取待审核评论列表

- 路径 /comment/admin_get_pending_comments
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名    | 类型 | 可选 | 解释     | 备注   |
| --------- | ---- | ---- | -------- | ------ |
| page      | int  | ✔    | 页码     | 默认1  |
| page_size | int  | ✔    | 每页数量 | 默认20 |

- 成功响应

| 字段名           | 类型 | 解释         | 备注 |
| ---------------- | ---- | ------------ | ---- |
| pending_comments | list | 待审核评论表 | -    |
| total            | int  | 总数         | -    |
| page             | int  | 当前页       | -    |

```python
@csrf_exempt
def admin_get_pending_comments(request):
    ok, resp = require_admin(request)
    if not ok: return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    data = json.loads(request.body)
    page = data.get("page", 1)
    page_size = data.get("page_size", 20)
    offset = (page - 1) * page_size

    # 查询条件：状态是 '审核中' 或 '举报中'
    sql = """
          SELECT c.comment_id, \
                 c.content, \
                 c.status, \
                 c.comment_time, \
                 c.target_type, \
                 c.target_id,
                 u.user_id, \
                 u.user_name, \
                 u.status as user_status
          FROM Comment c
                   JOIN User u ON c.user_id = u.user_id
          WHERE c.status IN ('审核中', '举报中')
          ORDER BY c.comment_time DESC
          LIMIT %s OFFSET %s \
          """

    # 统计总数
    sql_count = "SELECT COUNT(*) FROM Comment WHERE status IN ('审核中', '举报中')"

    with connection.cursor() as cursor:
        cursor.execute(sql, [page_size, offset])
        comments = dictfetchall(cursor)

        cursor.execute(sql_count)
        total = cursor.fetchone()[0]

    return json_cn({
        "pending_comments": comments,
        "total": total,
        "page": page
    })
```

##### 管理员审核评论

- 路径 /comment/admin_audit_comment/
- 方法 POST
- 路径参数 无
- 查询参数 无
- 请求体 表单数据

| 字段名     | 类型   | 可选 | 解释     | 备注             |
| ---------- | ------ | ---- | -------- | ---------------- |
| comment_id | int    | -    | 评论ID   | -                |
| result     | string | -    | 审核结果 | 'pass', 'reject' |
| ban_user   | bool   | ✔    | 是否封号 | 仅reject时有效   |

- 成功响应

| 字段名  | 类型   | 解释     | 备注 |
| ------- | ------ | -------- | ---- |
| message | string | 提示信息 | -    |

```python
@csrf_exempt
def admin_audit_comment(request):
    # 1. 权限检查
    ok, resp = require_admin(request)
    if not ok: return resp

    if request.method != "POST":
        return json_cn({"error": "POST required"}, 400)

    data = json.loads(request.body)
    comment_id = data.get("comment_id")
    audit_result = data.get("result")  # 'pass' (通过), 'reject' (驳回/删除)
    ban_user = data.get("ban_user", False)  # True (同时封禁用户)

    if not comment_id or audit_result not in ['pass', 'reject']:
        return json_cn({"error": "参数错误"}, 400)

    try:
        with connection.cursor() as cursor:

            # 先查一下评论信息 (为了获取 user_id 用于封禁)
            cursor.execute("SELECT user_id, content FROM Comment WHERE comment_id = %s", [comment_id])
            row = cursor.fetchone()
            if not row:
                return json_cn({"error": "评论不存在"}, 404)

            user_id, content_preview = row

            # ==============================
            # 情况 A: 审核通过 (改为正常)
            # ==============================
            if audit_result == 'pass':
                sql_pass = "UPDATE Comment SET status = '正常' WHERE comment_id = %s"
                cursor.execute(sql_pass, [comment_id])

                add_system_log(f"审核通过评论: {content_preview[:10]}...", "Comment", comment_id, "success")
                return json_cn({"message": "操作成功，评论已恢复正常"})

            # ==============================
            # 情况 B: 审核驳回 (删除评论)
            # ==============================
            elif audit_result == 'reject':

                # 1. 如果需要封禁用户
                if ban_user:
                    # 更新用户状态
                    sql_ban = "UPDATE User SET status = '封禁中' WHERE user_id = %s"
                    cursor.execute(sql_ban, [user_id])

                    # 这里只处理当前这一条评论。

                    add_system_log(f"封禁用户(因违规评论): ID={user_id}", "User", user_id, "success")

                # 2. 删除该条违规评论
                # 建议：如果只是"删除"，物理删除即可。
                # 如果想留存证据，可以把 status 改为 '已删除'
                # 这里直接删除
                sql_delete = "DELETE FROM Comment WHERE comment_id = %s"
                cursor.execute(sql_delete, [comment_id])

                action_msg = "审核驳回并删除" + ("(且封号)" if ban_user else "")
                add_system_log(f"{action_msg}: {content_preview[:10]}...", "Comment", comment_id, "success")

                return json_cn({"message": "违规评论已删除" + ("，用户已封禁" if ban_user else "")})

            return None

    except Exception as e:
        print(e)
        add_system_log(f"审核操作失败 ID={comment_id}", "Comment", comment_id, "fail")
        return json_cn({"error": "操作失败"}, 500)
```

## 三、 系统各项功能数据库端操作主要代码与结果说明

 

 

## 四、组员大作业总结

**注：小组内每位同学对所承担任务完成情况进行总结，包括任务内容概述、任务的难点以及解决难点的方法、任务完成结果、收获与体会。**

**@冯泽昊:**

**@欧阳晓宇:**